{"pages":[{"title":"关于","text":"博主是一条咸鱼,只能够被大家吊打. emmm,更新可能不会很实时,还有一些其他的功能没有更新.","link":"/about/index.html"},{"title":"友情链接","text":"hyjhyj water-mi","link":"/links/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"CF1154G Minimum Possible LCM","text":"传送门CodeForces 题目翻译Description给定一个长度为 $n$ 的序列 $a$，找出两个数，最小化他们的最小公倍数 Input第一行是一个整数 $n$下面一行 $n$ 个整数描述这个序列 Output输出一行两个整数代表这两个数在序列中的位置。如果有多解则任意输出一个即可。 Solution神仙题啊! 考虑$lcm$怎么算?$lcm$=$i$*$j$/$gcd$ 发现这个式子里面的$gcd$的范围可以枚举,那么直接枚举$gcd$,拿最小的两个出来算$lcm$就好了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)#define int llinline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=1000010,Max=1e7;int vis[Max+10],a[N],n,ans1,ans2;ll ans;signed main(){ n=gi();ans=1e18+10; for(re int i=1;i&lt;=n;i++) { a[i]=gi(); if(!vis[a[i]])vis[a[i]]=i; else if(ans&gt;a[i]){ans=a[i];ans1=i;ans2=vis[a[i]];} } for(re int i=1;i&lt;=Max;i++) { re ll find1=0,find2=0,where1,where2; for(re int j=i;j&lt;=Max;j+=i) { if(!vis[j])continue; if(!find1){find1=j;where1=vis[j];continue;} find2=j;where2=vis[j]; re ll lcm=1ll*find1/i*find2; if(lcm&lt;ans){ans=lcm;ans1=where1,ans2=where2;} break; } } if(ans1&gt;ans2)swap(ans1,ans2); printf(\"%lld %lld\\n\",ans1,ans2); return 0;}","link":"/cf1154g-minimum-possible-lcm/"},{"title":"BZOJ5312 - 冒险","text":"传送门BZOJ Solutionemmm,现在考虑一下怎么区间或和区间与.考虑如果一段区间的贡献没有什么用,显然不需要搞.考虑如果|的全是贡献的话,那么显然可以直接搞,就相当于是区间加法.如果&amp;的也是全是的,那么显然也可以直接搞,相当于是区间减法.然后就把这道题目转换成了区间+-然后求mx了.嗯嗯嗯嗯嗯,就是线段树板子了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=200010;struct node{ int And,Or,tag,mx;}t[N&lt;&lt;4];int a[N],n,m;void pushup(int);void add(int,int);void pushdown(int);void build(int,int,int);void modify_and(int,int,int,int,int,int);void modify_or(int,int,int,int,int,int);int query(int,int,int,int,int);int main(){ n=gi();m=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); build(1,1,n); while(m--) { int opt=gi(),l=gi(),r=gi(); if(opt==1) { int x=gi(); modify_and(1,1,n,l,r,x); } if(opt==2) { int x=gi(); modify_or(1,1,n,l,r,x); } if(opt==3) { printf(\"%d\\n\",query(1,1,n,l,r)); } } return 0;}void pushup(int o){ t[o].And=t[o&lt;&lt;1].And&amp;t[o&lt;&lt;1|1].And; t[o].Or=t[o&lt;&lt;1].Or|t[o&lt;&lt;1|1].Or; t[o].mx=max(t[o&lt;&lt;1].mx,t[o&lt;&lt;1|1].mx);}void build(int o,int l,int r){ if(l==r){t[o].mx=t[o].And=t[o].Or=a[l];return;} int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid);build(o&lt;&lt;1|1,mid+1,r); pushup(o);}void add(int o,int v){ t[o].tag+=v;t[o].And+=v;t[o].Or+=v;t[o].mx+=v;}void pushdown(int o){ if(t[o].tag) { add(o&lt;&lt;1,t[o].tag); add(o&lt;&lt;1|1,t[o].tag); t[o].tag=0; }}void modify_and(int o,int l,int r,int posl,int posr,int k){ if(l&lt;r)pushdown(o); if((t[o].Or&amp;k)==t[o].Or)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And&amp;k)-t[o].And==(t[o].Or&amp;k)-t[o].Or){add(o,(t[o].And&amp;k)-t[o].And);return;} int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_and(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_and(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else { modify_and(o&lt;&lt;1,l,mid,posl,mid,k); modify_and(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); } pushup(o);}void modify_or(int o,int l,int r,int posl,int posr,int k){ if(l&lt;r)pushdown(o); if((t[o].And|k)==t[o].And)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And|k)-t[o].And==(t[o].Or|k)-t[o].Or){add(o,(t[o].Or|k)-t[o].Or);return;} int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_or(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_or(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else { modify_or(o&lt;&lt;1,l,mid,posl,mid,k); modify_or(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); } pushup(o);}int query(int o,int l,int r,int posl,int posr){ if(l!=r)pushdown(o); if(posl&lt;=l &amp;&amp; r&lt;=posr)return t[o].mx; int mid=(l+r)&gt;&gt;1,res=0; if(posl&lt;=mid)res=max(res,query(o&lt;&lt;1,l,mid,posl,posr)); if(posr&gt;mid)res=max(res,query(o&lt;&lt;1|1,mid+1,r,posl,posr)); return res;}/*Kaiser终于成为冒险协会的一员，这次冒险协会派他去冒险，他来到一处古墓，却被大门上的守护神挡住了去路，守护神给出了一个问题，只有答对了问题才能进入，守护神给出了一个自然数序列a,每次有一下三种操作。1，给出l,r,x，将序列l,r之间的所有数都 and x2，给出l,r,x，将序列l,r之间的所有数都 or x3，给出l,r，询问l,r之间的最大值第一行包含两个整数 n,m 接下来一行包含 n 个整数, 表示a序列，接下来 m 行, 每行描述了一个操作.2&lt;=n&lt;=2e5 2&lt;=q&lt;=2e5,0&lt;=ai&lt;=2^20.*/","link":"/bzoj5312-冒险/"},{"title":"CodeForces802C Heidi and Library(hard)","text":"传送门CodeForces 题目翻译有$n$天和一个容量为$k$的书架,每天需要第$a_i$本书,买$i$这本书的代价是$c_i$,求满足每天条件的最小代价. Solution显然如果第$i$天需要$a_i$,那么$a_i$必须要在书架上面.考虑像餐巾计划一样把每一天拆成2个点,分别表示拥有的和需要的.显然当前这一天一定是连$(i,i+n,1,-Inf)$表示必须选.后面的随便连一下判断需不需要再买书就好了.最后跑k次费用流的费用就是答案.注意要把n*Inf的代价加上. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int Inf=1e7;struct node{ int to,nxt,flow,cost;}e[100010];int front[5010],n,s,t,cnt=1,dis[5010],vis[5010],fa[5010],from[5010],a[100010],c[100010];void Add(int u,int v,int flow,int cost){ e[++cnt]=(node){v,front[u],flow,cost};front[u]=cnt; e[++cnt]=(node){u,front[v],0,-cost};front[v]=cnt;}int flow,k,cost;queue&lt;int&gt;Q;bool SPFA(){ for(re int i=s;i&lt;=t;i++)dis[i]=Inf; Q.push(s); dis[s]=0;vis[s]=1; while(!Q.empty()){ int u=Q.front();Q.pop();vis[u]=0; for(re int i=front[u];i;i=e[i].nxt){ int v=e[i].to; if(e[i].flow &amp;&amp; dis[v]&gt;dis[u]+e[i].cost){ dis[v]=dis[u]+e[i].cost;fa[v]=u; from[v]=i; if(!vis[v]){ vis[v]=1;Q.push(v); } } } } if(dis[t]==Inf)return false; flow++;cost=min(cost,cost+dis[t]); for(re int i=t;i!=s;i=fa[i]){ e[from[i]].flow--;e[from[i]^1].flow++; } return true;}void McMf(){ while(k--)SPFA();}signed main(){ n=gi();k=gi(); t=n*2+1; for(int i=1;i&lt;=n;i++)a[i]=gi(); for(int i=1;i&lt;=n;i++)c[i]=gi(); for(int i=1;i&lt;=n;i++)Add(s,i,1,c[a[i]]); for(int i=1;i&lt;=n;i++)Add(i,i+n,1,-Inf); for(int i=1;i&lt;=n;i++)Add(i+n,t,1,0); for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) { Add(i+n,j,1,a[i]==a[j]?0:c[a[j]]); } cost+=1ll*n*Inf;k=min(k,n); McMf(); printf(\"%d\\n\",cost); return 0;}","link":"/codeforces802c-heidi-and-library-hard/"},{"title":"[HAOI2011]防线建设","text":"$\\texttt{stO}​$ $\\color{red}h \\color{black}{yjhyj​}$ $\\texttt{Orz}​$ 传送门BZOJ 然而是权限题 洛谷 Solution不会凸包的出门右转→ 考虑我们不会删点的动态凸包,但是这道题目只有删点,所以删点=加点! 那么怎么动态维护可以加点的凸包呢? 很显然每加入一个然后删除一些没有用的点就可以了. 这个东西平衡树查一下前驱就可以实现. set大法好! 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=200010;struct P{ int x,y; bool operator&lt;(const P &amp;b)const { return x&lt;b.x || (x==b.x &amp;&amp; y&lt;b.y); } int operator*(const P &amp;b)const { return x*b.y-y*b.x; } P operator-(const P &amp;b)const { return (P){x-b.x,y-b.y}; }}city[N];set&lt;P&gt;t;double now,ans[N];int del[N],tot,T,ask[N],n,x,y,mark[N];double dis(P a,P b){ return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}void insert(P &amp;x){ set&lt;P&gt;::iterator r=t.lower_bound(x),l=r,tmp; l--; if((*r-*l)*(x-*l)&lt;0)return; now-=dis(*l,*r); t.insert(x); while(1) { tmp=r;r++; if(r==t.end())break; if((*r-x)*(*tmp-x)&gt;0)break; now-=dis(*tmp,*r); t.erase(tmp); } while(l!=t.begin()) { tmp=l;l--; if((*tmp-x)*(*l-x)&gt;0)break; now-=dis(*tmp,*l); t.erase(tmp); } t.insert(x); l=r=t.find(x); l--;r++; now+=dis(*l,x)+dis(x,*r);}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin);#endif n=gi();x=gi(),y=gi(); t.insert((P){0,0}); t.insert((P){n,0}); P cap=(P){x,y}; t.insert(cap); now+=dis((P){0,0},cap); now+=dis((P){n,0},cap); int m=gi(); for(int i=1;i&lt;=m;i++) { int a=gi(),b=gi(); city[i]=(P){a,b}; } int q=gi(); for(int i=1;i&lt;=q;i++) { int opt=gi(); if(opt==1){int x=gi();del[++tot]=x,mark[x]=1;} else ask[++T]=tot; } for(int i=1;i&lt;=m;i++) if(!mark[i])insert(city[i]); for(int i=T;i&gt;=1;i--) { while(tot&gt;ask[i]) { insert(city[del[tot]]); tot--; } ans[i]=now; } for(int i=1;i&lt;=T;i++) printf(\"%.2lf\\n\",ans[i]); return 0;}","link":"/haoi2011-防线建设/"},{"title":"[USACO5.1] 圈奶牛Fencing the Cows","text":"传送门传送门 Solution这里主要介绍一下怎么写Andrew求凸包. 考虑我们按照 $x,y$ 的顺序排序,发现左下角和右上角的一定在凸包里面. 那么按照一般性的凸包求法然后叉积判一下就好了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=10010;struct node{ double x,y; node operator-(const node&amp;b)const{return (node){x-b.x,y-b.y};}}a[N];int n,top,s[N];bool cmp(node a,node b){ return a.x&lt;b.x || (a.x==b.x &amp;&amp; a.y&lt;b.y);}double cross(node a,node b){ return a.x*b.y-a.y*b.x;}double length(node a,node b){ return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}int main(){ n=gi(); for(int i=1;i&lt;=n;i++) { scanf(\"%lf%lf\",&amp;a[i].x,&amp;a[i].y); } sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) { while(top&gt;1 &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; } int tmp=top; for(int i=n-1;i&gt;=1;i--) { while(top&gt;tmp &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; } double Dis=0; for(int i=1;i&lt;top;i++) Dis+=length(a[s[i]],a[s[i+1]]); Dis+=length(a[s[1]],a[s[top]]); printf(\"%.2lf\\n\",Dis); return 0;}","link":"/usaco5-1-圈奶牛fencing-the-cows/"},{"title":"BZOJ3691 旅行","text":"传送门BZOJ 然而是权限题 Solution考虑C是变化的,然后他那个第一个部分的计算和费用流是不是很像? 然后把后面的放在一起算,前面的算一下费用流. 因为最短路是单调的,所以费用流的增广是一个单峰. 然后就可以了,在这个上面二分一下就知道答案了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=510,M=200010,Inf=1e9+10;int n,m,s,t,MaxFlow,MinCost,Q,g[N][N],val[N],tot,sum[N];int front[N],cnt,nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],c[M&lt;&lt;1],dis[N],vis[N],fa[N],from[N];bool SPFA(){ queue&lt;int &gt;Q;while(!Q.empty())Q.pop(); Q.push(s);memset(dis,127/2,sizeof(dis));vis[s]=1;dis[s]=0; while(!Q.empty()){ int u=Q.front();Q.pop();vis[u]=0; for(int i=front[u];i!=-1;i=nxt[i]){ int v=to[i]; if(w[i] &amp;&amp; dis[v]&gt;dis[u]+c[i]){ dis[v]=dis[u]+c[i];from[v]=i;fa[v]=u; if(!vis[v]){ vis[v]=1;Q.push(v); } } } } return dis[t+1]!=dis[t];}void Add_edge(int u,int v,int val,int f){to[cnt]=v;nxt[cnt]=front[u];front[u]=cnt;w[cnt]=val;c[cnt]=f;++cnt;}void Add(int u,int v,int val,int f){Add_edge(u,v,val,f);Add_edge(v,u,0,-f);}void init(){memset(front,-1,sizeof(front));cnt=0;}void Solve(){ while(SPFA()){ int d=Inf; for(int i=t;i!=s;i=fa[i])d=min(d,w[from[i]]); MaxFlow+=d;MinCost+=d*dis[t]; val[++tot]=d*dis[t];sum[tot]=sum[tot-1]+val[tot]; for(int i=t;i!=s;i=fa[i]){w[from[i]]-=d;w[from[i]^1]+=d;} }}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin);// freopen(\"out.out\",\"w\",stdout);#endif init(); n=gi();m=gi();Q=gi();s=0;t=n*2+1; memset(g,127/2,sizeof(g)); for(int i=1;i&lt;=n;i++) g[i][i]=0; for(int i=1;i&lt;=m;i++) { int u=gi(),v=gi(),w=gi(); g[u][v]=min(g[u][v],w); } for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=min(g[i][j],g[i][k]+g[k][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i^j) Add(i,j+n,1,g[i][j]); for(int i=1;i&lt;=n;i++)Add(s,i,1,0),Add(i+n,t,1,0); Solve(); while(Q--) { int C=gi(),l=1,r=tot,ans=0; while(l&lt;=r) { int mid=(l+r)&gt;&gt;1; if(val[mid]&gt;C)r=mid-1; else{l=mid+1;ans=mid;} } printf(\"%d\\n\",sum[ans]+(n-ans)*C); } return 0;}","link":"/bzoj3691-旅行/"},{"title":"POJ1149 PIGS","text":"传送门POJ 题目翻译现在有 $m$ 个猪圈,分别有 $a_i$ 头猪. 有 $n$ 个人要买猪,在 $k$ 个猪圈里面选,最多买 $b$ 头猪. 问最多买多少头猪. Solution发现这个数据范围很像网络流啊. 我们新建一个 $s$ , $t$ 节点. 把每一个人向 $t$ 节点连一个需求量,考虑每一个猪圈怎么解决: 我们想一下怎么转换模型,如果可以调换的话,相当于就是这些猪是一个整体对吧. 所以我们可以考虑把 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=10010,M=200010,Inf=1e9+10;int front[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],cnt=1,s,t,dep[N],m,n,pig[N],bl[N],cur[N];vector&lt;int&gt;g[N];queue&lt;int&gt;Q;void Add_edge(int u,int v,int val){ to[++cnt]=v;nxt[cnt]=front[u];w[cnt]=val;front[u]=cnt;}void Add(int u,int v,int val){ Add_edge(u,v,val); Add_edge(v,u,0);}bool bfs(){ memset(dep,0,sizeof(dep)); dep[s]=1;Q.push(s); while(!Q.empty()) { int u=Q.front();Q.pop(); for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(w[i] &amp;&amp; !dep[v]) { dep[v]=dep[u]+1;Q.push(v); } } } return dep[t];}int dfs(int u,int flow){ if(u==t || !flow)return flow; for(int &amp;i=cur[u];i;i=nxt[i]) { int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i]) { int di=dfs(v,min(flow,w[i])); if(di) { w[i]-=di;w[i^1]+=di; return di; } } } return 0;}int Dinic(){ int flow=0; while(bfs()) { for(int i=s;i&lt;=t;i++)cur[i]=front[i]; while(int d=dfs(s,Inf))flow+=d; } return flow;}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin); freopen(\"out.out\",\"w\",stdout);#endif memset(front,-1,sizeof(front)); m=gi();n=gi();t=n+1; for(int i=1;i&lt;=m;i++)pig[i]=gi(); for(int i=1;i&lt;=n;i++) { int k=gi(); for(int j=1;j&lt;=k;j++) g[i].push_back(gi()); Add(i,t,gi()); } for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;g[i].size();j++) { int v=g[i][j]; if(!bl[v]) { bl[v]=i; Add(s,i,pig[v]); } else { Add(bl[v],i,Inf); bl[v]=i; } } } printf(\"%d\\n\",Dinic()); return 0;}","link":"/poj1149-pigs/"},{"title":"CodeChef Querying on a Grid","text":"传送门CodeChef 题目翻译给你一个m*n的网格图(m&lt;=3),有Q个询问:opt=1,将(x1,y1)-&gt;(x2,y2)的最短路上的点权+c.opt=2,求点(x,y)的点权. Solution 网格图的一个基本套路就是分治(蒯的). 那么我们考虑分治,对于mid上面的3个点求一个最短路径树,那么现在最短路的长度就已知了. 然后再分治找路径就知道是路径了. 接着考虑修改,直接把这个修改改成子树修改就好了. 具体实现参考代码. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long longinline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}inline ll gl(){ ll f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=300010,M=4;typedef pair&lt;ll,int&gt; pii;#define mp make_pairvector&lt;pii&gt;g[N];int m,n,Q,tot,id[N][M];ll Max;struct node{ ll dis[N],c[N]; int fa[N],dfn[N],low[N],Time; vector&lt;int&gt;son[N]; bool vis[N]; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; void dfs(int u) { dfn[u]=++Time; for(int v:son[u])dfs(v); low[u]=Time; } int lowbit(int x) { return x&amp;(-x); } void Add(int x,ll d) { x=dfn[x]; while(x&lt;=Time) { c[x]+=d; x+=lowbit(x); } } ll query(int x) { ll ret=0;int tmp=x; tmp=low[x];while(tmp){ret+=c[tmp];tmp-=lowbit(tmp);} tmp=dfn[x]-1;while(tmp){ret-=c[tmp];tmp-=lowbit(tmp);} return ret; } void dijkstra(int l,int r,int s) { for(int i=l;i&lt;=r;i++) dis[i]=1e18,vis[i]=false; dis[s]=0; q.push(mp(0,s)); while(!q.empty()) { pii now=q.top();q.pop(); int u=now.second; if(vis[u])continue; vis[u]=1; for(pii i:g[u]) { int v=i.second;ll w=i.first; if(v&lt;l || v&gt;r || dis[v]&lt;=dis[u]+w)continue; dis[v]=dis[u]+w; fa[v]=u; q.push(mp(dis[v],v)); } } for(int i=l;i&lt;=r;i++) if(i!=s)son[fa[i]].push_back(i); dfs(s); }}t[20][M];void build(int l,int r,int dep){ int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) t[dep][i].dijkstra(id[l][0],id[r][m-1],id[mid][i]); if(l&lt;mid)build(l,mid-1,dep+1); if(r&gt;mid)build(mid+1,r,dep+1);}void calc(int l,int r,int dep,int u,int v){ int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) Max=min(Max,t[dep][i].dis[u]+t[dep][i].dis[v]); if(u&lt;=id[mid][m-1] &amp;&amp; v&gt;=id[mid][0])return; if(v&lt;id[mid][0])calc(l,mid-1,dep+1,u,v); else calc(mid+1,r,dep+1,u,v);}void modify(int l,int r,int dep,int x,int y,ll w){ int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) if(t[dep][i].dis[x]+t[dep][i].dis[y]==Max) { t[dep][i].Add(x,w); t[dep][i].Add(y,w); return; } if(y&lt;id[mid][0])modify(l,mid-1,dep+1,x,y,w); else modify(mid+1,r,dep+1,x,y,w);}ll query(int l,int r,int dep,int u){ int mid=(l+r)&gt;&gt;1;ll ret=0; for(int i=0;i&lt;m;i++) { ll s=t[dep][i].query(u); if(id[mid][i]==u)s&gt;&gt;=1; ret+=s; } if(u&lt;id[mid][0])ret+=query(l,mid-1,dep+1,u); if(u&gt;id[mid][m-1])ret+=query(mid+1,r,dep+1,u); return ret;}int main(){ m=gi();n=gi();Q=gi(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) id[i][j]=++tot; for(int i=0;i&lt;m-1;i++) for(int j=0;j&lt;n;j++) { int u=id[j][i],v=id[j][i+1];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); } for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n-1;j++) { int u=id[j][i],v=id[j+1][i];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); } build(0,n-1,0); while(Q--) { int opt=gi(); if(opt==1) { int x=gi()-1,y=gi()-1,xx=gi()-1,yy=gi()-1;ll c=gl(); int u=id[y][x],v=id[yy][xx]; if(u&gt;v)swap(u,v); Max=1e18;calc(0,n-1,0,u,v); modify(0,n-1,0,u,v,c); } else { int x=gi()-1,y=gi()-1; int u=id[y][x]; printf(\"%lld\\n\",query(0,n-1,0,u)); } } return 0;}","link":"/codechef-querying-on-a-grid/"},{"title":"Atcoder3611 Tree MST","text":"传送门Atcoder 题目翻译给你$n$个点的树,每条边有边权,每一个点有点权. 他们两两之间可以构成一个完全图,边$(u,v)$的代价是$w_u+w_v+dis(u,v)$. 求它的最小生成树. Solution考虑这个式子的形成: $w_u+w_v+dis(u,v)$ emmm,发现有个dis,考虑一下点分治! 对于每一个重心的子树,找一个$dis(u,root)+w[u]$的最小的点. 那么其他的点一定在这个子树里面到他最优. 然后直接连边然后跑最小生成树就好了. 复杂度的证明的话,就是: 点分的复杂度是$O(nlog(n))$的. 加入的边的级别是$O(nlog(n))$的. 总复杂度就是$O(nlog(n)^2)$的. 那么就可以放心的写了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;#define ll long long#define re registerusing namespace std;inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&lt;='9' &amp;&amp; ch&gt;='0'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=233333;int front[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],w[N&lt;&lt;1],W[N],n,m,cnt;int siz[N],g[N],root,sum,vis[N];struct node{ int u,v;ll w; bool operator&lt;(const node&amp;b)const { return w&lt;b.w; }}e[N*50];ll Min;int p;void Add(int u,int v,int val){ to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;}void getroot(int u,int fa){ siz[u]=1;g[u]=0; for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(v==fa || vis[v])continue; getroot(v,u); siz[u]+=siz[v]; g[u]=max(g[u],siz[v]); } g[u]=max(g[u],sum-siz[u]); if(g[u]&lt;g[root])root=u;}void dfs(int u,int fa,ll dep){ if(Min&gt;W[u]+dep){Min=W[u]+dep;p=u;} for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(v==fa || vis[v])continue; dfs(v,u,dep+w[i]); }}void Link(int u,int fa,ll dep){ e[++m]=(node){u,p,dep+Min+W[u]}; for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(v==fa || vis[v])continue; Link(v,u,dep+w[i]); }}void solve(int u){ vis[u]=1; Min=1e18+10;p=0; dfs(u,0,0);Link(u,0,0); for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(vis[v])continue; sum=siz[v];root=0; getroot(v,u); solve(root); }}int f[N];int find(int x){ if(f[x]!=x)f[x]=find(f[x]); return f[x];}int main(){ n=gi(); for(int i=1;i&lt;=n;i++)W[i]=gi(); for(int i=1;i&lt;n;i++) { int u=gi(),v=gi(),val=gi(); Add(u,v,val);Add(v,u,val); } g[0]=n+1;sum=n; getroot(1,0); solve(root); sort(e+1,e+m+1); for(int i=1;i&lt;=n;i++)f[i]=i; ll ans=0;int k=0; for(int i=1;i&lt;=m;i++) { int u=find(e[i].u),v=find(e[i].v); if(u!=v) { ans+=e[i].w; k++;f[v]=u; if(k==n-1)break; } } printf(\"%lld\\n\",ans); return 0;}","link":"/atcoder3611-tree-mst/"},{"title":"[JSOI2010]满汉全席","text":"传送门BZOJ Solution这不就是2-SAT的模板题?不会2-SAT模板?那你也是很菜了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=210,M=1010;int front[N],to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,dfn[N],Time,low[N],s[N],vis[N],sta,n,m,scc,bl[N];inline void Add(int u,int v){ to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;}void tarjan(int u){ dfn[u]=low[u]=++Time;s[sta++]=u;vis[u]=1; for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(!dfn[v]) { tarjan(v); low[u]=min(low[u],low[v]); } else if(vis[v])low[u]=min(low[u],dfn[v]); } if(dfn[u]==low[u]) { scc++; int x; do { x=s[--sta]; bl[x]=scc; vis[x]=0; }while(x!=u); }}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin); freopen(\"out.out\",\"w\",stdout);#endif int T=gi(); while(T--) { n=gi();m=gi(); for(re int i=1;i&lt;=n*2;i++)front[i]=0;cnt=0;Time=0;scc=0; for(re int i=1;i&lt;=n*2;i++)dfn[i]=low[i]=0; for(re int i=1;i&lt;=m;i++) { char ch=getchar();int a,b,x,y; while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); a=ch=='h'; x=gi(); ch=getchar(); while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); b=ch=='h'; y=gi(); Add(x+a*n,y+(b^1)*n); Add(y+b*n,x+(a^1)*n); } for(re int i=1;i&lt;=2*n;i++)if(!dfn[i])tarjan(i); int flag=0; for(re int i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) { puts(\"BAD\");flag=1;break; } if(!flag)puts(\"GOOD\"); } return 0;}","link":"/jsoi2010-满汉全席/"},{"title":"Cerc2012 Farm and factory","text":"传送门BZOJ很可惜这是一道权限题. Solution先设: $f_i$表示$1~i$的最短路. $g_i$表示$2~i$的最短路 $s_i$表示$new~i$的最短路 这个东西随便化简一下就是一个切比雪夫距离.发现这是一个正方形,旋转45°就是曼哈顿距离.然后中位数随便搞一下就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=100010,M=300010;const double Inf=1e18+10;int to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,front[N];typedef pair&lt;double,int&gt; pii;#define mp make_pairpriority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;double f[N],g[N],a[N],b[N],w[M&lt;&lt;1];int vis[N],n,m;void Add(int u,int v,double val){ to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin); freopen(\"out.out\",\"w\",stdout);#endif int T=gi(); while(T--) { memset(front,0,sizeof(front));cnt=0; n=gi();m=gi(); for(int i=1;i&lt;=m;i++) { int u=gi(),v=gi();double val;scanf(\"%lf\",&amp;val); Add(u,v,val);Add(v,u,val); } for(int i=1;i&lt;=n;i++)f[i]=Inf,vis[i]=0; f[1]=0.0;q.push(mp(0.0,1)); while(!q.empty()) { pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(f[v]&gt;f[u]+w[i]) { f[v]=f[u]+w[i]; q.push(mp(f[v],v)); } } } for(int i=1;i&lt;=n;i++)g[i]=Inf,vis[i]=0; g[2]=0.0;q.push(mp(0.0,2)); while(!q.empty()) { pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) { int v=to[i]; if(g[v]&gt;g[u]+w[i]) { g[v]=g[u]+w[i]; q.push(mp(g[v],v)); } } } for(int i=1;i&lt;=n;i++) a[i]=f[i]+g[i]; for(int i=1;i&lt;=n;i++) b[i]=f[i]-g[i]; sort(a+1,a+n+1);sort(b+1,b+n+1); double ans=0; for(int i=1;i&lt;=n;i++)ans+=fabs(a[i]-a[(n+1)/2]); for(int i=1;i&lt;=n;i++)ans+=fabs(b[i]-b[(n+1)/2]); ans/=2*n;printf(\"%.10lf\\n\",ans); } return 0;}","link":"/cerc2012-farm-and-factory/"},{"title":"Atcoder2134 Zigzag MST","text":"传送门Atcoder 题目翻译给出n个点,编号为0~n-1. 现在给出Q个加边操作,每一次的系数为$a,b,c$. 每一次可以插入无限条边,插入规则大致是:$(Ai,Bi,Ci)(Bi,Ai+1,Ci+1),(Ai+1,Bi+1,Ci+2)$等等,求给定图的最小生成树. Solution引入(假)在写题目之前先插播一条广告:有么有人资磁yyb小姐姐和zsy小哥哥在一起啊萝卜你应该要给我广告费 引入(真)如果现在有这样两条边摆在你面前:$(a,b,x)和(b,c,y)$我们知道$x&lt;y$,那么$(b,c,y)$就可以转换为$(a,c,y)$画一个图来深刻理解一下:其实这两个是等价的! 关于本题我们发现它的连边真心鬼畜,按照上面的那个什么替换一下?$(a,b,c)与(b,a+1,c+1)$emmm,这不就是$(a,b,c)与(a,a+1,c+1)$那么我们每一条限制就变成了一堆相邻的边的权值了.当然,注意$(a,b,c)$并没有消失!!!现在问题转换成如何快速求出每一条边的最小权值!注意到$a-&gt;a+1$和$b-&gt;b+1$一定是最小的两条边权,那么后面的一定会用它们更新!于是我们先把$a,b$的权值给赋上,然后按照顺序扫一遍就可以了.最后一个容易咕的地方就是:每次的贡献应当是$+2$而不是$+1$,因为它是两边同时进行. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=400010;int val[N],n,q,cnt,f[N];ll ans;struct node{ int u,v,w; bool operator&lt;(const node&amp;b)const { return w&lt;b.w; }}e[N&lt;&lt;1];int find(int x){ if(f[x]!=x)f[x]=find(f[x]); return f[x];}int main(){ n=gi();q=gi(); memset(val,127,sizeof(val)); for(int i=1;i&lt;=q;i++) { int a=gi(),b=gi(),c=gi(); e[++cnt]=(node){a,b,c}; val[a]=min(val[a],c+1); val[b]=min(val[b],c+2); } int pos=0; for(int i=1;i&lt;n;i++)if(val[pos]&gt;val[i])pos=i; for(int i=(pos+1)%n,j=pos;i!=pos;j=i,i=(i+1)%n) val[i]=min(val[i],val[j]+2); for(int i=0;i&lt;n-1;i++) e[++cnt]=(node){i,i+1,val[i]}; e[++cnt]=(node){n-1,0,val[n-1]}; sort(e+1,e+cnt+1); for(int i=0;i&lt;n;i++)f[i]=i; int k=0; for(int i=1;i&lt;=cnt;i++) { int u=e[i].u,v=e[i].v; if(find(u)!=find(v)) { ans+=e[i].w,f[find(u)]=find(v); k++; if(k==n-1)break; } } printf(\"%lld\\n\",ans); return 0;}","link":"/atcoder2134-zigzag-mst/"},{"title":"CodeForces891C Envy","text":"传送门CodeForces 题目翻译给你n个节点,m条边以及q条询问.每一次询问有k条边,询问这k条边能否都在MST上.可以就输出”YES”,否则输出”NO”. Solution这是一个翻遍全网都无法找到的新型题解!(至少在2019.3月份之前找不到)我们考虑最小生成树的一个性质: 加入完相同的边权后连通性是一样的. 证明: 考虑按照各种顺序排序,如果某一条边不会与其他的一同加入而产生环,那么显然他是一定会被加入的 如果有冲突,那么这些边的加入顺序就不重要了,因为他们一定会构成一个环少一条边. 那么利用这个性质,我们很容易做出来这道题目. 对于每一条边,假设它是一个三元组(u,v,w). 维护一个(uu,vv)表示加入完所有的$w’$&lt;$w$的边后的$u$所在的联通块和$v$所在的联通块. 我们考虑不能够插入的情况: 1find(uu)==find(vv) 那么只需要扫一遍所有的边,然后如果有不行的就直接输出”NO”,最后输出”YES”就好了. 当然跑的时候是需要维护连通性的(就是还是要加边!). 还原并查集数组的话可以把(uu,vv)当成是关键点,所以只需要改变这一些点的fa就可以了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=500010;struct node{ int u,v,w,uu,vv,id; bool operator&lt;(const node&amp;b)const { return w&lt;b.w; }}e[N],a[N];int f[N],n,m,q,c[N],id[N];int find(int x){ if(f[x]!=x)f[x]=find(f[x]); return f[x];}int main(){#ifndef ONLINE_JUDGE freopen(\"in.in\",\"r\",stdin); freopen(\"out.out\",\"w\",stdout);#endif n=gi();m=gi(); for(int i=1;i&lt;=m;i++) { e[i].u=gi(),e[i].v=gi(),e[i].w=gi(); e[i].id=i; } sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) id[e[i].id]=i; for(int i=1;i&lt;=n;i++)f[i]=i; int last=1; for(int i=1;i&lt;=m;i++) { if(e[i].w!=e[i-1].w) { for(int j=last;j&lt;i;j++) { int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; } last=i; } e[i].uu=find(e[i].u); e[i].vv=find(e[i].v); } for(int j=last;j&lt;=m;j++) { int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; }// for(int i=1;i&lt;=m;i++)// printf(\"%d %d %d %d %d\\n\",e[i].u,e[i].v,e[i].w,e[i].uu,e[i].vv); q=gi(); while(q--) { int k=gi(),sta=0; for(int i=1;i&lt;=k;i++) c[i]=gi(); for(int i=1;i&lt;=k;i++) { a[++sta]=e[id[c[i]]]; f[a[sta].uu]=a[sta].uu; f[a[sta].vv]=a[sta].vv; } sort(a+1,a+sta+1);int flag=0; for(int i=1;i&lt;=sta;i++) { int u=a[i].uu,v=a[i].vv; if(find(u)==find(v)) { flag=1;break; }// if(!q)printf(\"%d %d %d %d\\n\",u,v,find(u),find(v)); f[find(u)]=find(v); } if(flag)puts(\"NO\"); else puts(\"YES\"); } return 0;}","link":"/codeforces891c-envy/"},{"title":"HAOI2007 覆盖问题","text":"前言小清新思维题. 最近肯定需要一些思维题挽救我这种碰到题目只会模板的菜鸡. 这题腾空出世? Solution考虑一下我们二分答案怎么做? 首先转换一下,将这些点用一个尽可能小的矩形全部覆盖. 那么我们求的三个正方形一定会与这一些边有交. 然后前两个正方形直接看是和哪一个角相交.最后一个因为只剩下一个正方形,判断可行性即可. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int inf=1e9;struct data{int x[20010],y[20010],top;};int mid;void cut(data &amp;a,int x1,int y1,int x2,int y2){ int tot=0; for(int i=1;i&lt;=a.top;i++) if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) { tot++; a.x[tot]=a.x[i]; a.y[tot]=a.y[i]; } a.top=tot;} void solve(data &amp;a,int fc){ int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=a.top;i++) { x1=min(a.x[i],x1),x2=max(a.x[i],x2); y1=min(a.y[i],y1),y2=max(a.y[i],y2); } if(fc==1) cut(a,x1,y1,x1+mid,y1+mid); if(fc==2) cut(a,x2-mid,y1,x2,y1+mid); if(fc==3) cut(a,x1,y2-mid,x1+mid,y2); if(fc==4) cut(a,x2-mid,y2-mid,x2,y2);}data a;bool jud(){ data b; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) { b.top=a.top; for(int i=1;i&lt;=b.top;i++) b.x[i]=a.x[i],b.y[i]=a.y[i]; solve(b,x);solve(b,y); int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=b.top;i++) { x1=min(b.x[i],x1),x2=max(b.x[i],x2); y1=min(b.y[i],y1),y2=max(b.y[i],y2); } if(x2-x1&lt;=mid&amp;&amp;y2-y1&lt;=mid)return 1; } return 0;}int main(){ int n=gi(); for(int i=1;i&lt;=n;i++)a.x[i]=gi(),a.y[i]=gi(); a.top=n; int l=1,r=inf,ans=0; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(jud()){r=mid-1;ans=mid;} else l=mid+1; } printf(\"%d\\n\",ans); return 0;}","link":"/haoi2007-覆盖问题/"},{"title":"HAOI2006 数字序列","text":"dp好题? 第一问第一问我会做!令$b_i=a_i-i$,求一个最长不下降子序列. $n-ans$就是最终的答案. 第二问好难啊.不会.挖坑待补. 考虑一下对于一个i~j的可能符合情况,定然存在一个$k$在i~k之中为$a_i$,k~j之中为$a_j$. 然后就可以dp了. 这个转移比较玄学.如果不随机就GG了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)inline int gi(){ int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0'){if(ch=='-')f=-1;ch=getchar();} while(ch&gt;='0' &amp;&amp; ch&lt;='9'){sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();} return f*sum;}const int N=50010;int a[N],n,L,cnt,mn[N],f[N],front[N],to[N&lt;&lt;2],nxt[N&lt;&lt;2];ll g[N],s1[N],s2[N];int find(int x){ int l=1,r=L,t=0; while(l&lt;=r){ int mid=(l+r)&gt;&gt;1; if(mn[mid]&lt;=x)t=mid,l=mid+1; else r=mid-1; } return t;}void dp(){ memset(mn,127,sizeof(mn)); mn[0]=-(1&lt;&lt;30); for(int i=1;i&lt;=n;i++){ int q=find(a[i]); f[i]=q+1; L=max(L,f[i]); mn[q+1]=min(mn[q+1],a[i]); }}void Add(int u,int v){ to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;}void solve(){ for(int i=n;~i;i--){ Add(f[i],i); g[i]=1ll&lt;&lt;60; } g[0]=0;a[0]=-(1&lt;&lt;30); for(int u=1;u&lt;=n;u++) for(int i=front[f[u]-1];i;i=nxt[i]){ int v=to[i]; if(v&gt;u)break; if(a[v]&gt;a[u])continue; for(int j=v;j&lt;=u;j++)s1[j]=abs(a[v]-a[j]),s2[j]=abs(a[u]-a[j]); for(int j=v+1;j&lt;=u;j++) s1[j]+=s1[j-1],s2[j]+=s2[j-1]; for(int j=v;j&lt;u;j++) g[u]=min(g[u],g[v]+s1[j]-s1[v]+s2[u]-s2[j]); }}int main(){ n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi()-i; a[++n]=1&lt;&lt;30; dp();solve(); printf(\"%d\\n%lld\\n\",n-f[n],g[n]); return 0;}","link":"/haoi2006-数字序列/"},{"title":"欢迎来到我的博客","text":"欢迎来到我的hexo博客! emmm,我也不知道自己有多少博客,但是这一次一定是最后一个了. 希望能够开的很久吧.","link":"/欢迎来到我的博客/"}],"tags":[{"name":"并查集","slug":"并查集","link":"/tags/并查集/"},{"name":"Kruscal","slug":"Kruscal","link":"/tags/Kruscal/"},{"name":"Trick","slug":"Trick","link":"/tags/Trick/"},{"name":"图论","slug":"图论","link":"/tags/图论/"},{"name":"点分治","slug":"点分治","link":"/tags/点分治/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"二分答案","slug":"二分答案","link":"/tags/二分答案/"},{"name":"贪心","slug":"贪心","link":"/tags/贪心/"},{"name":"网络流","slug":"网络流","link":"/tags/网络流/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"几何","slug":"几何","link":"/tags/几何/"},{"name":"数学","slug":"数学","link":"/tags/数学/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"分治","slug":"分治","link":"/tags/分治/"},{"name":"最短路径树","slug":"最短路径树","link":"/tags/最短路径树/"},{"name":"建模","slug":"建模","link":"/tags/建模/"},{"name":"凸包","slug":"凸包","link":"/tags/凸包/"},{"name":"动态凸包","slug":"动态凸包","link":"/tags/动态凸包/"},{"name":"计算几何","slug":"计算几何","link":"/tags/计算几何/"},{"name":"2-SAT","slug":"2-SAT","link":"/tags/2-SAT/"},{"name":"介绍","slug":"介绍","link":"/tags/介绍/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"其他","slug":"其他","link":"/categories/其他/"}]}