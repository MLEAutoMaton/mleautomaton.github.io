<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ5312 - 冒险]]></title>
    <url>%2Fbzoj5312-%E5%86%92%E9%99%A9%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solutionemmm,现在考虑一下怎么区间或和区间与.考虑如果一段区间的贡献没有什么用,显然不需要搞.考虑如果|的全是贡献的话,那么显然可以直接搞,就相当于是区间加法.如果&amp;的也是全是的,那么显然也可以直接搞,相当于是区间减法.然后就把这道题目转换成了区间+-然后求mx了.嗯嗯嗯嗯嗯,就是线段树板子了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010;struct node&#123; int And,Or,tag,mx;&#125;t[N&lt;&lt;4];int a[N],n,m;void pushup(int);void add(int,int);void pushdown(int);void build(int,int,int);void modify_and(int,int,int,int,int,int);void modify_or(int,int,int,int,int,int);int query(int,int,int,int,int);int main()&#123; n=gi();m=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); build(1,1,n); while(m--) &#123; int opt=gi(),l=gi(),r=gi(); if(opt==1) &#123; int x=gi(); modify_and(1,1,n,l,r,x); &#125; if(opt==2) &#123; int x=gi(); modify_or(1,1,n,l,r,x); &#125; if(opt==3) &#123; printf("%d\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;void pushup(int o)&#123; t[o].And=t[o&lt;&lt;1].And&amp;t[o&lt;&lt;1|1].And; t[o].Or=t[o&lt;&lt;1].Or|t[o&lt;&lt;1|1].Or; t[o].mx=max(t[o&lt;&lt;1].mx,t[o&lt;&lt;1|1].mx);&#125;void build(int o,int l,int r)&#123; if(l==r)&#123;t[o].mx=t[o].And=t[o].Or=a[l];return;&#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid);build(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void add(int o,int v)&#123; t[o].tag+=v;t[o].And+=v;t[o].Or+=v;t[o].mx+=v;&#125;void pushdown(int o)&#123; if(t[o].tag) &#123; add(o&lt;&lt;1,t[o].tag); add(o&lt;&lt;1|1,t[o].tag); t[o].tag=0; &#125;&#125;void modify_and(int o,int l,int r,int posl,int posr,int k)&#123; if(l&lt;r)pushdown(o); if((t[o].Or&amp;k)==t[o].Or)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And&amp;k)-t[o].And==(t[o].Or&amp;k)-t[o].Or)&#123;add(o,(t[o].And&amp;k)-t[o].And);return;&#125; int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_and(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_and(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else &#123; modify_and(o&lt;&lt;1,l,mid,posl,mid,k); modify_and(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); &#125; pushup(o);&#125;void modify_or(int o,int l,int r,int posl,int posr,int k)&#123; if(l&lt;r)pushdown(o); if((t[o].And|k)==t[o].And)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And|k)-t[o].And==(t[o].Or|k)-t[o].Or)&#123;add(o,(t[o].Or|k)-t[o].Or);return;&#125; int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_or(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_or(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else &#123; modify_or(o&lt;&lt;1,l,mid,posl,mid,k); modify_or(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); &#125; pushup(o);&#125;int query(int o,int l,int r,int posl,int posr)&#123; if(l!=r)pushdown(o); if(posl&lt;=l &amp;&amp; r&lt;=posr)return t[o].mx; int mid=(l+r)&gt;&gt;1,res=0; if(posl&lt;=mid)res=max(res,query(o&lt;&lt;1,l,mid,posl,posr)); if(posr&gt;mid)res=max(res,query(o&lt;&lt;1|1,mid+1,r,posl,posr)); return res;&#125;/*Kaiser终于成为冒险协会的一员，这次冒险协会派他去冒险，他来到一处古墓，却被大门上的守护神挡住了去路，守护神给出了一个问题，只有答对了问题才能进入，守护神给出了一个自然数序列a,每次有一下三种操作。1，给出l,r,x，将序列l,r之间的所有数都 and x2，给出l,r,x，将序列l,r之间的所有数都 or x3，给出l,r，询问l,r之间的最大值第一行包含两个整数 n,m 接下来一行包含 n 个整数, 表示a序列，接下来 m 行, 每行描述了一个操作.2&lt;=n&lt;=2e5 2&lt;=q&lt;=2e5,0&lt;=ai&lt;=2^20.*/]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces802C Heidi and Library(hard)]]></title>
    <url>%2Fcodeforces802c-heidi-and-library-hard%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译有$n$天和一个容量为$k$的书架,每天需要第$a_i$本书,买$i$这本书的代价是$c_i$,求满足每天条件的最小代价. Solution显然如果第$i$天需要$a_i$,那么$a_i$必须要在书架上面.考虑像餐巾计划一样把每一天拆成2个点,分别表示拥有的和需要的.显然当前这一天一定是连$(i,i+n,1,-Inf)$表示必须选.后面的随便连一下判断需不需要再买书就好了.最后跑k次费用流的费用就是答案.注意要把n*Inf的代价加上. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int Inf=1e7;struct node&#123; int to,nxt,flow,cost;&#125;e[100010];int front[5010],n,s,t,cnt=1,dis[5010],vis[5010],fa[5010],from[5010],a[100010],c[100010];void Add(int u,int v,int flow,int cost)&#123; e[++cnt]=(node)&#123;v,front[u],flow,cost&#125;;front[u]=cnt; e[++cnt]=(node)&#123;u,front[v],0,-cost&#125;;front[v]=cnt;&#125;int flow,k,cost;queue&lt;int&gt;Q;bool SPFA()&#123; for(re int i=s;i&lt;=t;i++)dis[i]=Inf; Q.push(s); dis[s]=0;vis[s]=1; while(!Q.empty())&#123; int u=Q.front();Q.pop();vis[u]=0; for(re int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(e[i].flow &amp;&amp; dis[v]&gt;dis[u]+e[i].cost)&#123; dis[v]=dis[u]+e[i].cost;fa[v]=u; from[v]=i; if(!vis[v])&#123; vis[v]=1;Q.push(v); &#125; &#125; &#125; &#125; if(dis[t]==Inf)return false; flow++;cost=min(cost,cost+dis[t]); for(re int i=t;i!=s;i=fa[i])&#123; e[from[i]].flow--;e[from[i]^1].flow++; &#125; return true;&#125;void McMf()&#123; while(k--)SPFA();&#125;signed main()&#123; n=gi();k=gi(); t=n*2+1; for(int i=1;i&lt;=n;i++)a[i]=gi(); for(int i=1;i&lt;=n;i++)c[i]=gi(); for(int i=1;i&lt;=n;i++)Add(s,i,1,c[a[i]]); for(int i=1;i&lt;=n;i++)Add(i,i+n,1,-Inf); for(int i=1;i&lt;=n;i++)Add(i+n,t,1,0); for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) &#123; Add(i+n,j,1,a[i]==a[j]?0:c[a[j]]); &#125; cost+=1ll*n*Inf;k=min(k,n); McMf(); printf("%d\n",cost); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2011]防线建设]]></title>
    <url>%2Fhaoi2011-%E9%98%B2%E7%BA%BF%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[$\texttt{stO}​$ $\color{red}h \color{black}{yjhyj​}$ $\texttt{Orz}​$ 传送门BZOJ 然而是权限题 洛谷 Solution不会凸包的出门右转→ 考虑我们不会删点的动态凸包,但是这道题目只有删点,所以删点=加点! 那么怎么动态维护可以加点的凸包呢? 很显然每加入一个然后删除一些没有用的点就可以了. 这个东西平衡树查一下前驱就可以实现. set大法好! 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010;struct P&#123; int x,y; bool operator&lt;(const P &amp;b)const &#123; return x&lt;b.x || (x==b.x &amp;&amp; y&lt;b.y); &#125; int operator*(const P &amp;b)const &#123; return x*b.y-y*b.x; &#125; P operator-(const P &amp;b)const &#123; return (P)&#123;x-b.x,y-b.y&#125;; &#125;&#125;city[N];set&lt;P&gt;t;double now,ans[N];int del[N],tot,T,ask[N],n,x,y,mark[N];double dis(P a,P b)&#123; return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void insert(P &amp;x)&#123; set&lt;P&gt;::iterator r=t.lower_bound(x),l=r,tmp; l--; if((*r-*l)*(x-*l)&lt;0)return; now-=dis(*l,*r); t.insert(x); while(1) &#123; tmp=r;r++; if(r==t.end())break; if((*r-x)*(*tmp-x)&gt;0)break; now-=dis(*tmp,*r); t.erase(tmp); &#125; while(l!=t.begin()) &#123; tmp=l;l--; if((*tmp-x)*(*l-x)&gt;0)break; now-=dis(*tmp,*l); t.erase(tmp); &#125; t.insert(x); l=r=t.find(x); l--;r++; now+=dis(*l,x)+dis(x,*r);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);#endif n=gi();x=gi(),y=gi(); t.insert((P)&#123;0,0&#125;); t.insert((P)&#123;n,0&#125;); P cap=(P)&#123;x,y&#125;; t.insert(cap); now+=dis((P)&#123;0,0&#125;,cap); now+=dis((P)&#123;n,0&#125;,cap); int m=gi(); for(int i=1;i&lt;=m;i++) &#123; int a=gi(),b=gi(); city[i]=(P)&#123;a,b&#125;; &#125; int q=gi(); for(int i=1;i&lt;=q;i++) &#123; int opt=gi(); if(opt==1)&#123;int x=gi();del[++tot]=x,mark[x]=1;&#125; else ask[++T]=tot; &#125; for(int i=1;i&lt;=m;i++) if(!mark[i])insert(city[i]); for(int i=T;i&gt;=1;i--) &#123; while(tot&gt;ask[i]) &#123; insert(city[del[tot]]); tot--; &#125; ans[i]=now; &#125; for(int i=1;i&lt;=T;i++) printf("%.2lf\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>动态凸包</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.1] 圈奶牛Fencing the Cows]]></title>
    <url>%2Fusaco5-1-%E5%9C%88%E5%A5%B6%E7%89%9Bfencing-the-cows%2F</url>
    <content type="text"><![CDATA[传送门传送门 Solution这里主要介绍一下怎么写Andrew求凸包. 考虑我们按照 $x,y$ 的顺序排序,发现左下角和右上角的一定在凸包里面. 那么按照一般性的凸包求法然后叉积判一下就好了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=10010;struct node&#123; double x,y; node operator-(const node&amp;b)const&#123;return (node)&#123;x-b.x,y-b.y&#125;;&#125;&#125;a[N];int n,top,s[N];bool cmp(node a,node b)&#123; return a.x&lt;b.x || (a.x==b.x &amp;&amp; a.y&lt;b.y);&#125;double cross(node a,node b)&#123; return a.x*b.y-a.y*b.x;&#125;double length(node a,node b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;1 &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; &#125; int tmp=top; for(int i=n-1;i&gt;=1;i--) &#123; while(top&gt;tmp &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; &#125; double Dis=0; for(int i=1;i&lt;top;i++) Dis+=length(a[s[i]],a[s[i+1]]); Dis+=length(a[s[1]],a[s[top]]); printf("%.2lf\n",Dis); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>凸包</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3691 旅行]]></title>
    <url>%2Fbzoj3691-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[传送门BZOJ 然而是权限题 Solution考虑C是变化的,然后他那个第一个部分的计算和费用流是不是很像? 然后把后面的放在一起算,前面的算一下费用流. 因为最短路是单调的,所以费用流的增广是一个单峰. 然后就可以了,在这个上面二分一下就知道答案了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=510,M=200010,Inf=1e9+10;int n,m,s,t,MaxFlow,MinCost,Q,g[N][N],val[N],tot,sum[N];int front[N],cnt,nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],c[M&lt;&lt;1],dis[N],vis[N],fa[N],from[N];bool SPFA()&#123; queue&lt;int &gt;Q;while(!Q.empty())Q.pop(); Q.push(s);memset(dis,127/2,sizeof(dis));vis[s]=1;dis[s]=0; while(!Q.empty())&#123; int u=Q.front();Q.pop();vis[u]=0; for(int i=front[u];i!=-1;i=nxt[i])&#123; int v=to[i]; if(w[i] &amp;&amp; dis[v]&gt;dis[u]+c[i])&#123; dis[v]=dis[u]+c[i];from[v]=i;fa[v]=u; if(!vis[v])&#123; vis[v]=1;Q.push(v); &#125; &#125; &#125; &#125; return dis[t+1]!=dis[t];&#125;void Add_edge(int u,int v,int val,int f)&#123;to[cnt]=v;nxt[cnt]=front[u];front[u]=cnt;w[cnt]=val;c[cnt]=f;++cnt;&#125;void Add(int u,int v,int val,int f)&#123;Add_edge(u,v,val,f);Add_edge(v,u,0,-f);&#125;void init()&#123;memset(front,-1,sizeof(front));cnt=0;&#125;void Solve()&#123; while(SPFA())&#123; int d=Inf; for(int i=t;i!=s;i=fa[i])d=min(d,w[from[i]]); MaxFlow+=d;MinCost+=d*dis[t]; val[++tot]=d*dis[t];sum[tot]=sum[tot-1]+val[tot]; for(int i=t;i!=s;i=fa[i])&#123;w[from[i]]-=d;w[from[i]^1]+=d;&#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);// freopen("out.out","w",stdout);#endif init(); n=gi();m=gi();Q=gi();s=0;t=n*2+1; memset(g,127/2,sizeof(g)); for(int i=1;i&lt;=n;i++) g[i][i]=0; for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi(),w=gi(); g[u][v]=min(g[u][v],w); &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=min(g[i][j],g[i][k]+g[k][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i^j) Add(i,j+n,1,g[i][j]); for(int i=1;i&lt;=n;i++)Add(s,i,1,0),Add(i+n,t,1,0); Solve(); while(Q--) &#123; int C=gi(),l=1,r=tot,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(val[mid]&gt;C)r=mid-1; else&#123;l=mid+1;ans=mid;&#125; &#125; printf("%d\n",sum[ans]+(n-ans)*C); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1149 PIGS]]></title>
    <url>%2Fpoj1149-pigs%2F</url>
    <content type="text"><![CDATA[传送门POJ 题目翻译现在有 $m$ 个猪圈,分别有 $a_i$ 头猪. 有 $n$ 个人要买猪,在 $k$ 个猪圈里面选,最多买 $b$ 头猪. 问最多买多少头猪. Solution发现这个数据范围很像网络流啊. 我们新建一个 $s$ , $t$ 节点. 把每一个人向 $t$ 节点连一个需求量,考虑每一个猪圈怎么解决: 我们想一下怎么转换模型,如果可以调换的话,相当于就是这些猪是一个整体对吧. 所以我们可以考虑把 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=10010,M=200010,Inf=1e9+10;int front[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],cnt=1,s,t,dep[N],m,n,pig[N],bl[N],cur[N];vector&lt;int&gt;g[N];queue&lt;int&gt;Q;void Add_edge(int u,int v,int val)&#123; to[++cnt]=v;nxt[cnt]=front[u];w[cnt]=val;front[u]=cnt;&#125;void Add(int u,int v,int val)&#123; Add_edge(u,v,val); Add_edge(v,u,0);&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); dep[s]=1;Q.push(s); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v]) &#123; dep[v]=dep[u]+1;Q.push(v); &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t || !flow)return flow; for(int &amp;i=cur[u];i;i=nxt[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i]) &#123; int di=dfs(v,min(flow,w[i])); if(di) &#123; w[i]-=di;w[i^1]+=di; return di; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs()) &#123; for(int i=s;i&lt;=t;i++)cur[i]=front[i]; while(int d=dfs(s,Inf))flow+=d; &#125; return flow;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif memset(front,-1,sizeof(front)); m=gi();n=gi();t=n+1; for(int i=1;i&lt;=m;i++)pig[i]=gi(); for(int i=1;i&lt;=n;i++) &#123; int k=gi(); for(int j=1;j&lt;=k;j++) g[i].push_back(gi()); Add(i,t,gi()); &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;g[i].size();j++) &#123; int v=g[i][j]; if(!bl[v]) &#123; bl[v]=i; Add(s,i,pig[v]); &#125; else &#123; Add(bl[v],i,Inf); bl[v]=i; &#125; &#125; &#125; printf("%d\n",Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeChef Querying on a Grid]]></title>
    <url>%2Fcodechef-querying-on-a-grid%2F</url>
    <content type="text"><![CDATA[传送门CodeChef 题目翻译给你一个m*n的网格图(m&lt;=3),有Q个询问:opt=1,将(x1,y1)-&gt;(x2,y2)的最短路上的点权+c.opt=2,求点(x,y)的点权. Solution 网格图的一个基本套路就是分治(蒯的). 那么我们考虑分治,对于mid上面的3个点求一个最短路径树,那么现在最短路的长度就已知了. 然后再分治找路径就知道是路径了. 接着考虑修改,直接把这个修改改成子树修改就好了. 具体实现参考代码. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;inline ll gl()&#123; ll f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=300010,M=4;typedef pair&lt;ll,int&gt; pii;#define mp make_pairvector&lt;pii&gt;g[N];int m,n,Q,tot,id[N][M];ll Max;struct node&#123; ll dis[N],c[N]; int fa[N],dfn[N],low[N],Time; vector&lt;int&gt;son[N]; bool vis[N]; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; void dfs(int u) &#123; dfn[u]=++Time; for(int v:son[u])dfs(v); low[u]=Time; &#125; int lowbit(int x) &#123; return x&amp;(-x); &#125; void Add(int x,ll d) &#123; x=dfn[x]; while(x&lt;=Time) &#123; c[x]+=d; x+=lowbit(x); &#125; &#125; ll query(int x) &#123; ll ret=0;int tmp=x; tmp=low[x];while(tmp)&#123;ret+=c[tmp];tmp-=lowbit(tmp);&#125; tmp=dfn[x]-1;while(tmp)&#123;ret-=c[tmp];tmp-=lowbit(tmp);&#125; return ret; &#125; void dijkstra(int l,int r,int s) &#123; for(int i=l;i&lt;=r;i++) dis[i]=1e18,vis[i]=false; dis[s]=0; q.push(mp(0,s)); while(!q.empty()) &#123; pii now=q.top();q.pop(); int u=now.second; if(vis[u])continue; vis[u]=1; for(pii i:g[u]) &#123; int v=i.second;ll w=i.first; if(v&lt;l || v&gt;r || dis[v]&lt;=dis[u]+w)continue; dis[v]=dis[u]+w; fa[v]=u; q.push(mp(dis[v],v)); &#125; &#125; for(int i=l;i&lt;=r;i++) if(i!=s)son[fa[i]].push_back(i); dfs(s); &#125;&#125;t[20][M];void build(int l,int r,int dep)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) t[dep][i].dijkstra(id[l][0],id[r][m-1],id[mid][i]); if(l&lt;mid)build(l,mid-1,dep+1); if(r&gt;mid)build(mid+1,r,dep+1);&#125;void calc(int l,int r,int dep,int u,int v)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) Max=min(Max,t[dep][i].dis[u]+t[dep][i].dis[v]); if(u&lt;=id[mid][m-1] &amp;&amp; v&gt;=id[mid][0])return; if(v&lt;id[mid][0])calc(l,mid-1,dep+1,u,v); else calc(mid+1,r,dep+1,u,v);&#125;void modify(int l,int r,int dep,int x,int y,ll w)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) if(t[dep][i].dis[x]+t[dep][i].dis[y]==Max) &#123; t[dep][i].Add(x,w); t[dep][i].Add(y,w); return; &#125; if(y&lt;id[mid][0])modify(l,mid-1,dep+1,x,y,w); else modify(mid+1,r,dep+1,x,y,w);&#125;ll query(int l,int r,int dep,int u)&#123; int mid=(l+r)&gt;&gt;1;ll ret=0; for(int i=0;i&lt;m;i++) &#123; ll s=t[dep][i].query(u); if(id[mid][i]==u)s&gt;&gt;=1; ret+=s; &#125; if(u&lt;id[mid][0])ret+=query(l,mid-1,dep+1,u); if(u&gt;id[mid][m-1])ret+=query(mid+1,r,dep+1,u); return ret;&#125;int main()&#123; m=gi();n=gi();Q=gi(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) id[i][j]=++tot; for(int i=0;i&lt;m-1;i++) for(int j=0;j&lt;n;j++) &#123; int u=id[j][i],v=id[j][i+1];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n-1;j++) &#123; int u=id[j][i],v=id[j+1][i];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); &#125; build(0,n-1,0); while(Q--) &#123; int opt=gi(); if(opt==1) &#123; int x=gi()-1,y=gi()-1,xx=gi()-1,yy=gi()-1;ll c=gl(); int u=id[y][x],v=id[yy][xx]; if(u&gt;v)swap(u,v); Max=1e18;calc(0,n-1,0,u,v); modify(0,n-1,0,u,v,c); &#125; else &#123; int x=gi()-1,y=gi()-1; int u=id[y][x]; printf("%lld\n",query(0,n-1,0,u)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>分治</tag>
        <tag>最短路径树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder3611 Tree MST]]></title>
    <url>%2Fatcoder3611-tree-mst%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给你$n$个点的树,每条边有边权,每一个点有点权. 他们两两之间可以构成一个完全图,边$(u,v)$的代价是$w_u+w_v+dis(u,v)$. 求它的最小生成树. Solution考虑这个式子的形成: $w_u+w_v+dis(u,v)$ emmm,发现有个dis,考虑一下点分治! 对于每一个重心的子树,找一个$dis(u,root)+w[u]$的最小的点. 那么其他的点一定在这个子树里面到他最优. 然后直接连边然后跑最小生成树就好了. 复杂度的证明的话,就是: 点分的复杂度是$O(nlog(n))$的. 加入的边的级别是$O(nlog(n))$的. 总复杂度就是$O(nlog(n)^2)$的. 那么就可以放心的写了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;#define ll long long#define re registerusing namespace std;inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&lt;='9' &amp;&amp; ch&gt;='0')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=233333;int front[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],w[N&lt;&lt;1],W[N],n,m,cnt;int siz[N],g[N],root,sum,vis[N];struct node&#123; int u,v;ll w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N*50];ll Min;int p;void Add(int u,int v,int val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;void getroot(int u,int fa)&#123; siz[u]=1;g[u]=0; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; getroot(v,u); siz[u]+=siz[v]; g[u]=max(g[u],siz[v]); &#125; g[u]=max(g[u],sum-siz[u]); if(g[u]&lt;g[root])root=u;&#125;void dfs(int u,int fa,ll dep)&#123; if(Min&gt;W[u]+dep)&#123;Min=W[u]+dep;p=u;&#125; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; dfs(v,u,dep+w[i]); &#125;&#125;void Link(int u,int fa,ll dep)&#123; e[++m]=(node)&#123;u,p,dep+Min+W[u]&#125;; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; Link(v,u,dep+w[i]); &#125;&#125;void solve(int u)&#123; vis[u]=1; Min=1e18+10;p=0; dfs(u,0,0);Link(u,0,0); for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(vis[v])continue; sum=siz[v];root=0; getroot(v,u); solve(root); &#125;&#125;int f[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)W[i]=gi(); for(int i=1;i&lt;n;i++) &#123; int u=gi(),v=gi(),val=gi(); Add(u,v,val);Add(v,u,val); &#125; g[0]=n+1;sum=n; getroot(1,0); solve(root); sort(e+1,e+m+1); for(int i=1;i&lt;=n;i++)f[i]=i; ll ans=0;int k=0; for(int i=1;i&lt;=m;i++) &#123; int u=find(e[i].u),v=find(e[i].v); if(u!=v) &#123; ans+=e[i].w; k++;f[v]=u; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>Kruscal</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JSOI2010]满汉全席]]></title>
    <url>%2Fjsoi2010-%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solution这不就是2-SAT的模板题?不会2-SAT模板?那你也是很菜了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=210,M=1010;int front[N],to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,dfn[N],Time,low[N],s[N],vis[N],sta,n,m,scc,bl[N];inline void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++Time;s[sta++]=u;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; scc++; int x; do &#123; x=s[--sta]; bl[x]=scc; vis[x]=0; &#125;while(x!=u); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; n=gi();m=gi(); for(re int i=1;i&lt;=n*2;i++)front[i]=0;cnt=0;Time=0;scc=0; for(re int i=1;i&lt;=n*2;i++)dfn[i]=low[i]=0; for(re int i=1;i&lt;=m;i++) &#123; char ch=getchar();int a,b,x,y; while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); a=ch=='h'; x=gi(); ch=getchar(); while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); b=ch=='h'; y=gi(); Add(x+a*n,y+(b^1)*n); Add(y+b*n,x+(a^1)*n); &#125; for(re int i=1;i&lt;=2*n;i++)if(!dfn[i])tarjan(i); int flag=0; for(re int i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) &#123; puts("BAD");flag=1;break; &#125; if(!flag)puts("GOOD"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cerc2012 Farm and factory]]></title>
    <url>%2Fcerc2012-farm-and-factory%2F</url>
    <content type="text"><![CDATA[传送门BZOJ很可惜这是一道权限题. Solution先设: $f_i$表示$1~i$的最短路. $g_i$表示$2~i$的最短路 $s_i$表示$new~i$的最短路 这个东西随便化简一下就是一个切比雪夫距离.发现这是一个正方形,旋转45°就是曼哈顿距离.然后中位数随便搞一下就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,M=300010;const double Inf=1e18+10;int to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,front[N];typedef pair&lt;double,int&gt; pii;#define mp make_pairpriority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;double f[N],g[N],a[N],b[N],w[M&lt;&lt;1];int vis[N],n,m;void Add(int u,int v,double val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; memset(front,0,sizeof(front));cnt=0; n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi();double val;scanf("%lf",&amp;val); Add(u,v,val);Add(v,u,val); &#125; for(int i=1;i&lt;=n;i++)f[i]=Inf,vis[i]=0; f[1]=0.0;q.push(mp(0.0,1)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(f[v]&gt;f[u]+w[i]) &#123; f[v]=f[u]+w[i]; q.push(mp(f[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)g[i]=Inf,vis[i]=0; g[2]=0.0;q.push(mp(0.0,2)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(g[v]&gt;g[u]+w[i]) &#123; g[v]=g[u]+w[i]; q.push(mp(g[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) a[i]=f[i]+g[i]; for(int i=1;i&lt;=n;i++) b[i]=f[i]-g[i]; sort(a+1,a+n+1);sort(b+1,b+n+1); double ans=0; for(int i=1;i&lt;=n;i++)ans+=fabs(a[i]-a[(n+1)/2]); for(int i=1;i&lt;=n;i++)ans+=fabs(b[i]-b[(n+1)/2]); ans/=2*n;printf("%.10lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder2134 Zigzag MST]]></title>
    <url>%2Fatcoder2134-zigzag-mst%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给出n个点,编号为0~n-1. 现在给出Q个加边操作,每一次的系数为$a,b,c$. 每一次可以插入无限条边,插入规则大致是:$(Ai,Bi,Ci)(Bi,Ai+1,Ci+1),(Ai+1,Bi+1,Ci+2)$等等,求给定图的最小生成树. Solution引入(假)在写题目之前先插播一条广告:有么有人资磁yyb小姐姐和zsy小哥哥在一起啊萝卜你应该要给我广告费 引入(真)如果现在有这样两条边摆在你面前:$(a,b,x)和(b,c,y)$我们知道$x&lt;y$,那么$(b,c,y)$就可以转换为$(a,c,y)$画一个图来深刻理解一下:其实这两个是等价的! 关于本题我们发现它的连边真心鬼畜,按照上面的那个什么替换一下?$(a,b,c)与(b,a+1,c+1)$emmm,这不就是$(a,b,c)与(a,a+1,c+1)$那么我们每一条限制就变成了一堆相邻的边的权值了.当然,注意$(a,b,c)$并没有消失!!!现在问题转换成如何快速求出每一条边的最小权值!注意到$a-&gt;a+1$和$b-&gt;b+1$一定是最小的两条边权,那么后面的一定会用它们更新!于是我们先把$a,b$的权值给赋上,然后按照顺序扫一遍就可以了.最后一个容易咕的地方就是:每次的贡献应当是$+2$而不是$+1$,因为它是两边同时进行. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=400010;int val[N],n,q,cnt,f[N];ll ans;struct node&#123; int u,v,w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N&lt;&lt;1];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi();q=gi(); memset(val,127,sizeof(val)); for(int i=1;i&lt;=q;i++) &#123; int a=gi(),b=gi(),c=gi(); e[++cnt]=(node)&#123;a,b,c&#125;; val[a]=min(val[a],c+1); val[b]=min(val[b],c+2); &#125; int pos=0; for(int i=1;i&lt;n;i++)if(val[pos]&gt;val[i])pos=i; for(int i=(pos+1)%n,j=pos;i!=pos;j=i,i=(i+1)%n) val[i]=min(val[i],val[j]+2); for(int i=0;i&lt;n-1;i++) e[++cnt]=(node)&#123;i,i+1,val[i]&#125;; e[++cnt]=(node)&#123;n-1,0,val[n-1]&#125;; sort(e+1,e+cnt+1); for(int i=0;i&lt;n;i++)f[i]=i; int k=0; for(int i=1;i&lt;=cnt;i++) &#123; int u=e[i].u,v=e[i].v; if(find(u)!=find(v)) &#123; ans+=e[i].w,f[find(u)]=find(v); k++; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces891C Envy]]></title>
    <url>%2Fcodeforces891c-envy%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译给你n个节点,m条边以及q条询问.每一次询问有k条边,询问这k条边能否都在MST上.可以就输出”YES”,否则输出”NO”. Solution这是一个翻遍全网都无法找到的新型题解!(至少在2019.3月份之前找不到)我们考虑最小生成树的一个性质: 加入完相同的边权后连通性是一样的. 证明: 考虑按照各种顺序排序,如果某一条边不会与其他的一同加入而产生环,那么显然他是一定会被加入的 如果有冲突,那么这些边的加入顺序就不重要了,因为他们一定会构成一个环少一条边. 那么利用这个性质,我们很容易做出来这道题目. 对于每一条边,假设它是一个三元组(u,v,w). 维护一个(uu,vv)表示加入完所有的$w’$&lt;$w$的边后的$u$所在的联通块和$v$所在的联通块. 我们考虑不能够插入的情况: 1find(uu)==find(vv) 那么只需要扫一遍所有的边,然后如果有不行的就直接输出”NO”,最后输出”YES”就好了. 当然跑的时候是需要维护连通性的(就是还是要加边!). 还原并查集数组的话可以把(uu,vv)当成是关键点,所以只需要改变这一些点的fa就可以了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=500010;struct node&#123; int u,v,w,uu,vv,id; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N],a[N];int f[N],n,m,q,c[N],id[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; e[i].u=gi(),e[i].v=gi(),e[i].w=gi(); e[i].id=i; &#125; sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) id[e[i].id]=i; for(int i=1;i&lt;=n;i++)f[i]=i; int last=1; for(int i=1;i&lt;=m;i++) &#123; if(e[i].w!=e[i-1].w) &#123; for(int j=last;j&lt;i;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125; last=i; &#125; e[i].uu=find(e[i].u); e[i].vv=find(e[i].v); &#125; for(int j=last;j&lt;=m;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125;// for(int i=1;i&lt;=m;i++)// printf("%d %d %d %d %d\n",e[i].u,e[i].v,e[i].w,e[i].uu,e[i].vv); q=gi(); while(q--) &#123; int k=gi(),sta=0; for(int i=1;i&lt;=k;i++) c[i]=gi(); for(int i=1;i&lt;=k;i++) &#123; a[++sta]=e[id[c[i]]]; f[a[sta].uu]=a[sta].uu; f[a[sta].vv]=a[sta].vv; &#125; sort(a+1,a+sta+1);int flag=0; for(int i=1;i&lt;=sta;i++) &#123; int u=a[i].uu,v=a[i].vv; if(find(u)==find(v)) &#123; flag=1;break; &#125;// if(!q)printf("%d %d %d %d\n",u,v,find(u),find(v)); f[find(u)]=find(v); &#125; if(flag)puts("NO"); else puts("YES"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2007 覆盖问题]]></title>
    <url>%2Fhaoi2007-%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言小清新思维题. 最近肯定需要一些思维题挽救我这种碰到题目只会模板的菜鸡. 这题腾空出世? Solution考虑一下我们二分答案怎么做? 首先转换一下,将这些点用一个尽可能小的矩形全部覆盖. 那么我们求的三个正方形一定会与这一些边有交. 然后前两个正方形直接看是和哪一个角相交.最后一个因为只剩下一个正方形,判断可行性即可. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int inf=1e9;struct data&#123;int x[20010],y[20010],top;&#125;;int mid;void cut(data &amp;a,int x1,int y1,int x2,int y2)&#123; int tot=0; for(int i=1;i&lt;=a.top;i++) if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) &#123; tot++; a.x[tot]=a.x[i]; a.y[tot]=a.y[i]; &#125; a.top=tot;&#125; void solve(data &amp;a,int fc)&#123; int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=a.top;i++) &#123; x1=min(a.x[i],x1),x2=max(a.x[i],x2); y1=min(a.y[i],y1),y2=max(a.y[i],y2); &#125; if(fc==1) cut(a,x1,y1,x1+mid,y1+mid); if(fc==2) cut(a,x2-mid,y1,x2,y1+mid); if(fc==3) cut(a,x1,y2-mid,x1+mid,y2); if(fc==4) cut(a,x2-mid,y2-mid,x2,y2);&#125;data a;bool jud()&#123; data b; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; b.top=a.top; for(int i=1;i&lt;=b.top;i++) b.x[i]=a.x[i],b.y[i]=a.y[i]; solve(b,x);solve(b,y); int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=b.top;i++) &#123; x1=min(b.x[i],x1),x2=max(b.x[i],x2); y1=min(b.y[i],y1),y2=max(b.y[i],y2); &#125; if(x2-x1&lt;=mid&amp;&amp;y2-y1&lt;=mid)return 1; &#125; return 0;&#125;int main()&#123; int n=gi(); for(int i=1;i&lt;=n;i++)a.x[i]=gi(),a.y[i]=gi(); a.top=n; int l=1,r=inf,ans=0; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(jud())&#123;r=mid-1;ans=mid;&#125; else l=mid+1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2006 数字序列]]></title>
    <url>%2Fhaoi2006-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[dp好题? 第一问第一问我会做!令$b_i=a_i-i$,求一个最长不下降子序列. $n-ans$就是最终的答案. 第二问好难啊.不会.挖坑待补. 考虑一下对于一个i~j的可能符合情况,定然存在一个$k$在i~k之中为$a_i$,k~j之中为$a_j$. 然后就可以dp了. 这个转移比较玄学.如果不随机就GG了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010;int a[N],n,L,cnt,mn[N],f[N],front[N],to[N&lt;&lt;2],nxt[N&lt;&lt;2];ll g[N],s1[N],s2[N];int find(int x)&#123; int l=1,r=L,t=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(mn[mid]&lt;=x)t=mid,l=mid+1; else r=mid-1; &#125; return t;&#125;void dp()&#123; memset(mn,127,sizeof(mn)); mn[0]=-(1&lt;&lt;30); for(int i=1;i&lt;=n;i++)&#123; int q=find(a[i]); f[i]=q+1; L=max(L,f[i]); mn[q+1]=min(mn[q+1],a[i]); &#125;&#125;void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void solve()&#123; for(int i=n;~i;i--)&#123; Add(f[i],i); g[i]=1ll&lt;&lt;60; &#125; g[0]=0;a[0]=-(1&lt;&lt;30); for(int u=1;u&lt;=n;u++) for(int i=front[f[u]-1];i;i=nxt[i])&#123; int v=to[i]; if(v&gt;u)break; if(a[v]&gt;a[u])continue; for(int j=v;j&lt;=u;j++)s1[j]=abs(a[v]-a[j]),s2[j]=abs(a[u]-a[j]); for(int j=v+1;j&lt;=u;j++) s1[j]+=s1[j-1],s2[j]+=s2[j-1]; for(int j=v;j&lt;u;j++) g[u]=min(g[u],g[v]+s1[j]-s1[v]+s2[u]-s2[j]); &#125;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi()-i; a[++n]=1&lt;&lt;30; dp();solve(); printf("%d\n%lld\n",n-f[n],g[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[欢迎来到我的hexo博客! emmm,我也不知道自己有多少博客,但是这一次一定是最后一个了. 希望能够开的很久吧.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
