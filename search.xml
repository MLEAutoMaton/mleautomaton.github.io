<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HAOI2007 覆盖问题]]></title>
    <url>%2F2019%2F03%2F01%2FBZOJ1052%2F</url>
    <content type="text"><![CDATA[前言小清新思维题. 最近肯定需要一些思维题挽救我这种碰到题目只会模板的菜鸡. 这题腾空出世? Solution考虑一下我们二分答案怎么做? 首先转换一下,将这些点用一个尽可能小的矩形全部覆盖. 那么我们求的三个正方形一定会与这一些边有交. 然后前两个正方形直接看是和哪一个角相交.最后一个因为只剩下一个正方形,判断可行性即可. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int inf=1e9;struct data&#123;int x[20010],y[20010],top;&#125;;int mid;void cut(data &amp;a,int x1,int y1,int x2,int y2)&#123; int tot=0; for(int i=1;i&lt;=a.top;i++) if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) &#123; tot++; a.x[tot]=a.x[i]; a.y[tot]=a.y[i]; &#125; a.top=tot;&#125; void solve(data &amp;a,int fc)&#123; int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=a.top;i++) &#123; x1=min(a.x[i],x1),x2=max(a.x[i],x2); y1=min(a.y[i],y1),y2=max(a.y[i],y2); &#125; if(fc==1) cut(a,x1,y1,x1+mid,y1+mid); if(fc==2) cut(a,x2-mid,y1,x2,y1+mid); if(fc==3) cut(a,x1,y2-mid,x1+mid,y2); if(fc==4) cut(a,x2-mid,y2-mid,x2,y2);&#125;data a;bool jud()&#123; data b; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; b.top=a.top; for(int i=1;i&lt;=b.top;i++) b.x[i]=a.x[i],b.y[i]=a.y[i]; solve(b,x);solve(b,y); int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=b.top;i++) &#123; x1=min(b.x[i],x1),x2=max(b.x[i],x2); y1=min(b.y[i],y1),y2=max(b.y[i],y2); &#125; if(x2-x1&lt;=mid&amp;&amp;y2-y1&lt;=mid)return 1; &#125; return 0;&#125;int main()&#123; int n=gi(); for(int i=1;i&lt;=n;i++)a.x[i]=gi(),a.y[i]=gi(); a.top=n; int l=1,r=inf,ans=0; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(jud())&#123;r=mid-1;ans=mid;&#125; else l=mid+1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2006 数字序列]]></title>
    <url>%2F2019%2F03%2F01%2FBZOJ1049%2F</url>
    <content type="text"><![CDATA[dp好题? 第一问第一问我会做!令$b_i=a_i-i$,求一个最长不下降子序列. $n-ans$就是最终的答案. 第二问好难啊.不会.挖坑待补. 考虑一下对于一个i~j的可能符合情况,定然存在一个$k$在i~k之中为$a_i$,k~j之中为$a_j$. 然后就可以dp了. 这个转移比较玄学.如果不随机就GG了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010;int a[N],n,L,cnt,mn[N],f[N],front[N],to[N&lt;&lt;2],nxt[N&lt;&lt;2];ll g[N],s1[N],s2[N];int find(int x)&#123; int l=1,r=L,t=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(mn[mid]&lt;=x)t=mid,l=mid+1; else r=mid-1; &#125; return t;&#125;void dp()&#123; memset(mn,127,sizeof(mn)); mn[0]=-(1&lt;&lt;30); for(int i=1;i&lt;=n;i++)&#123; int q=find(a[i]); f[i]=q+1; L=max(L,f[i]); mn[q+1]=min(mn[q+1],a[i]); &#125;&#125;void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void solve()&#123; for(int i=n;~i;i--)&#123; Add(f[i],i); g[i]=1ll&lt;&lt;60; &#125; g[0]=0;a[0]=-(1&lt;&lt;30); for(int u=1;u&lt;=n;u++) for(int i=front[f[u]-1];i;i=nxt[i])&#123; int v=to[i]; if(v&gt;u)break; if(a[v]&gt;a[u])continue; for(int j=v;j&lt;=u;j++)s1[j]=abs(a[v]-a[j]),s2[j]=abs(a[u]-a[j]); for(int j=v+1;j&lt;=u;j++) s1[j]+=s1[j-1],s2[j]+=s2[j-1]; for(int j=v;j&lt;u;j++) g[u]=min(g[u],g[v]+s1[j]-s1[v]+s2[u]-s2[j]); &#125;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi()-i; a[++n]=1&lt;&lt;30; dp();solve(); printf("%d\n%lld\n",n-f[n],g[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F2019%2F02%2F28%2FWelcome%20To%20My%20Blog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的hexo博客! emmm,我也不知道自己有多少博客,但是这一次一定是最后一个了. 希望能够开的很久吧.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
