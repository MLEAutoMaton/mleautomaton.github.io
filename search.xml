<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Atcoder3611 Tree MST]]></title>
    <url>%2F2019%2F03%2F03%2FAT3611%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给你$n$个点的树,每条边有边权,每一个点有点权. 他们两两之间可以构成一个完全图,边$(u,v)$的代价是$w_u+w_v+dis(u,v)$. 求它的最小生成树. Solution考虑这个式子的形成: $w_u+w_v+dis(u,v)$ emmm,发现有个dis,考虑一下点分治! 对于每一个重心的子树,找一个$dis(u,root)+w[u]$的最小的点. 那么其他的点一定在这个子树里面到他最优. 然后直接连边然后跑最小生成树就好了. 复杂度的证明的话,就是: 点分的复杂度是$O(nlog(n))$的. 加入的边的级别是$O(nlog(n))$的. 总复杂度就是$O(nlog(n)^2)$的. 那么就可以放心的写了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;#define ll long long#define re registerusing namespace std;inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&lt;='9' &amp;&amp; ch&gt;='0')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=233333;int front[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],w[N&lt;&lt;1],W[N],n,m,cnt;int siz[N],g[N],root,sum,vis[N];struct node&#123; int u,v;ll w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N*50];ll Min;int p;void Add(int u,int v,int val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;void getroot(int u,int fa)&#123; siz[u]=1;g[u]=0; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; getroot(v,u); siz[u]+=siz[v]; g[u]=max(g[u],siz[v]); &#125; g[u]=max(g[u],sum-siz[u]); if(g[u]&lt;g[root])root=u;&#125;void dfs(int u,int fa,ll dep)&#123; if(Min&gt;W[u]+dep)&#123;Min=W[u]+dep;p=u;&#125; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; dfs(v,u,dep+w[i]); &#125;&#125;void Link(int u,int fa,ll dep)&#123; e[++m]=(node)&#123;u,p,dep+Min+W[u]&#125;; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; Link(v,u,dep+w[i]); &#125;&#125;void solve(int u)&#123; vis[u]=1; Min=1e18+10;p=0; dfs(u,0,0);Link(u,0,0); for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(vis[v])continue; sum=siz[v];root=0; getroot(v,u); solve(root); &#125;&#125;int f[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)W[i]=gi(); for(int i=1;i&lt;n;i++) &#123; int u=gi(),v=gi(),val=gi(); Add(u,v,val);Add(v,u,val); &#125; g[0]=n+1;sum=n; getroot(1,0); solve(root); sort(e+1,e+m+1); for(int i=1;i&lt;=n;i++)f[i]=i; ll ans=0;int k=0; for(int i=1;i&lt;=m;i++) &#123; int u=find(e[i].u),v=find(e[i].v); if(u!=v) &#123; ans+=e[i].w; k++;f[v]=u; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>Kruscal</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JSOI2010]满汉全席]]></title>
    <url>%2F2019%2F03%2F02%2FJSOI2010-%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solution这不就是2-SAT的模板题?不会2-SAT模板?那你也是很菜了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=210,M=1010;int front[N],to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,dfn[N],Time,low[N],s[N],vis[N],sta,n,m,scc,bl[N];inline void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++Time;s[sta++]=u;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; scc++; int x; do &#123; x=s[--sta]; bl[x]=scc; vis[x]=0; &#125;while(x!=u); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; n=gi();m=gi(); for(re int i=1;i&lt;=n*2;i++)front[i]=0;cnt=0;Time=0;scc=0; for(re int i=1;i&lt;=n*2;i++)dfn[i]=low[i]=0; for(re int i=1;i&lt;=m;i++) &#123; char ch=getchar();int a,b,x,y; while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); a=ch=='h'; x=gi(); ch=getchar(); while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); b=ch=='h'; y=gi(); Add(x+a*n,y+(b^1)*n); Add(y+b*n,x+(a^1)*n); &#125; for(re int i=1;i&lt;=2*n;i++)if(!dfn[i])tarjan(i); int flag=0; for(re int i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) &#123; puts("BAD");flag=1;break; &#125; if(!flag)puts("GOOD"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cerc2012 Farm and factory]]></title>
    <url>%2F2019%2F03%2F01%2FBZOJ4061%2F</url>
    <content type="text"><![CDATA[传送门BZOJ很可惜这是一道权限题. Solution先设: $f_i$表示$1~i$的最短路. $g_i$表示$2~i$的最短路 $s_i$表示$new~i$的最短路 这个东西随便化简一下就是一个切比雪夫距离.发现这是一个正方形,旋转45°就是曼哈顿距离.然后中位数随便搞一下就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,M=300010;const double Inf=1e18+10;int to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,front[N];typedef pair&lt;double,int&gt; pii;#define mp make_pairpriority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;double f[N],g[N],a[N],b[N],w[M&lt;&lt;1];int vis[N],n,m;void Add(int u,int v,double val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; memset(front,0,sizeof(front));cnt=0; n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi();double val;scanf("%lf",&amp;val); Add(u,v,val);Add(v,u,val); &#125; for(int i=1;i&lt;=n;i++)f[i]=Inf,vis[i]=0; f[1]=0.0;q.push(mp(0.0,1)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(f[v]&gt;f[u]+w[i]) &#123; f[v]=f[u]+w[i]; q.push(mp(f[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)g[i]=Inf,vis[i]=0; g[2]=0.0;q.push(mp(0.0,2)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(g[v]&gt;g[u]+w[i]) &#123; g[v]=g[u]+w[i]; q.push(mp(g[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) a[i]=f[i]+g[i]; for(int i=1;i&lt;=n;i++) b[i]=f[i]-g[i]; sort(a+1,a+n+1);sort(b+1,b+n+1); double ans=0; for(int i=1;i&lt;=n;i++)ans+=fabs(a[i]-a[(n+1)/2]); for(int i=1;i&lt;=n;i++)ans+=fabs(b[i]-b[(n+1)/2]); ans/=2*n;printf("%.10lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder2134 Zigzag MST]]></title>
    <url>%2F2019%2F03%2F01%2FAT2134%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给出n个点,编号为0~n-1. 现在给出Q个加边操作,每一次的系数为$a,b,c$. 每一次可以插入无限条边,插入规则大致是:$(Ai,Bi,Ci)(Bi,Ai+1,Ci+1),(Ai+1,Bi+1,Ci+2)$等等,求给定图的最小生成树. Solution引入(假)在写题目之前先插播一条广告:有么有人资磁yyb小姐姐和zsy小哥哥在一起啊萝卜你应该要给我广告费 引入(真)如果现在有这样两条边摆在你面前:$(a,b,x)和(b,c,y)$我们知道$x&lt;y$,那么$(b,c,y)$就可以转换为$(a,c,y)$画一个图来深刻理解一下:其实这两个是等价的! 关于本题我们发现它的连边真心鬼畜,按照上面的那个什么替换一下?$(a,b,c)与(b,a+1,c+1)$emmm,这不就是$(a,b,c)与(a,a+1,c+1)$那么我们每一条限制就变成了一堆相邻的边的权值了.当然,注意$(a,b,c)$并没有消失!!!现在问题转换成如何快速求出每一条边的最小权值!注意到$a-&gt;a+1$和$b-&gt;b+1$一定是最小的两条边权,那么后面的一定会用它们更新!于是我们先把$a,b$的权值给赋上,然后按照顺序扫一遍就可以了.最后一个容易咕的地方就是:每次的贡献应当是$+2$而不是$+1$,因为它是两边同时进行. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=400010;int val[N],n,q,cnt,f[N];ll ans;struct node&#123; int u,v,w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N&lt;&lt;1];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi();q=gi(); memset(val,127,sizeof(val)); for(int i=1;i&lt;=q;i++) &#123; int a=gi(),b=gi(),c=gi(); e[++cnt]=(node)&#123;a,b,c&#125;; val[a]=min(val[a],c+1); val[b]=min(val[b],c+2); &#125; int pos=0; for(int i=1;i&lt;n;i++)if(val[pos]&gt;val[i])pos=i; for(int i=(pos+1)%n,j=pos;i!=pos;j=i,i=(i+1)%n) val[i]=min(val[i],val[j]+2); for(int i=0;i&lt;n-1;i++) e[++cnt]=(node)&#123;i,i+1,val[i]&#125;; e[++cnt]=(node)&#123;n-1,0,val[n-1]&#125;; sort(e+1,e+cnt+1); for(int i=0;i&lt;n;i++)f[i]=i; int k=0; for(int i=1;i&lt;=cnt;i++) &#123; int u=e[i].u,v=e[i].v; if(find(u)!=find(v)) &#123; ans+=e[i].w,f[find(u)]=find(v); k++; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces891C Envy]]></title>
    <url>%2F2019%2F03%2F01%2FCodeForces891C%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译给你n个节点,m条边以及q条询问.每一次询问有k条边,询问这k条边能否都在MST上.可以就输出”YES”,否则输出”NO”. Solution这是一个翻遍全网都无法找到的新型题解!(至少在2019.3月份之前找不到)我们考虑最小生成树的一个性质: 加入完相同的边权后连通性是一样的. 证明: 考虑按照各种顺序排序,如果某一条边不会与其他的一同加入而产生环,那么显然他是一定会被加入的 如果有冲突,那么这些边的加入顺序就不重要了,因为他们一定会构成一个环少一条边. 那么利用这个性质,我们很容易做出来这道题目. 对于每一条边,假设它是一个三元组(u,v,w). 维护一个(uu,vv)表示加入完所有的$w’$&lt;$w$的边后的$u$所在的联通块和$v$所在的联通块. 我们考虑不能够插入的情况: 1find(uu)==find(vv) 那么只需要扫一遍所有的边,然后如果有不行的就直接输出”NO”,最后输出”YES”就好了. 当然跑的时候是需要维护连通性的(就是还是要加边!). 还原并查集数组的话可以把(uu,vv)当成是关键点,所以只需要改变这一些点的fa就可以了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=500010;struct node&#123; int u,v,w,uu,vv,id; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N],a[N];int f[N],n,m,q,c[N],id[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; e[i].u=gi(),e[i].v=gi(),e[i].w=gi(); e[i].id=i; &#125; sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) id[e[i].id]=i; for(int i=1;i&lt;=n;i++)f[i]=i; int last=1; for(int i=1;i&lt;=m;i++) &#123; if(e[i].w!=e[i-1].w) &#123; for(int j=last;j&lt;i;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125; last=i; &#125; e[i].uu=find(e[i].u); e[i].vv=find(e[i].v); &#125; for(int j=last;j&lt;=m;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125;// for(int i=1;i&lt;=m;i++)// printf("%d %d %d %d %d\n",e[i].u,e[i].v,e[i].w,e[i].uu,e[i].vv); q=gi(); while(q--) &#123; int k=gi(),sta=0; for(int i=1;i&lt;=k;i++) c[i]=gi(); for(int i=1;i&lt;=k;i++) &#123; a[++sta]=e[id[c[i]]]; f[a[sta].uu]=a[sta].uu; f[a[sta].vv]=a[sta].vv; &#125; sort(a+1,a+sta+1);int flag=0; for(int i=1;i&lt;=sta;i++) &#123; int u=a[i].uu,v=a[i].vv; if(find(u)==find(v)) &#123; flag=1;break; &#125;// if(!q)printf("%d %d %d %d\n",u,v,find(u),find(v)); f[find(u)]=find(v); &#125; if(flag)puts("NO"); else puts("YES"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2007 覆盖问题]]></title>
    <url>%2F2019%2F03%2F01%2FBZOJ1052%2F</url>
    <content type="text"><![CDATA[前言小清新思维题. 最近肯定需要一些思维题挽救我这种碰到题目只会模板的菜鸡. 这题腾空出世? Solution考虑一下我们二分答案怎么做? 首先转换一下,将这些点用一个尽可能小的矩形全部覆盖. 那么我们求的三个正方形一定会与这一些边有交. 然后前两个正方形直接看是和哪一个角相交.最后一个因为只剩下一个正方形,判断可行性即可. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int inf=1e9;struct data&#123;int x[20010],y[20010],top;&#125;;int mid;void cut(data &amp;a,int x1,int y1,int x2,int y2)&#123; int tot=0; for(int i=1;i&lt;=a.top;i++) if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) &#123; tot++; a.x[tot]=a.x[i]; a.y[tot]=a.y[i]; &#125; a.top=tot;&#125; void solve(data &amp;a,int fc)&#123; int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=a.top;i++) &#123; x1=min(a.x[i],x1),x2=max(a.x[i],x2); y1=min(a.y[i],y1),y2=max(a.y[i],y2); &#125; if(fc==1) cut(a,x1,y1,x1+mid,y1+mid); if(fc==2) cut(a,x2-mid,y1,x2,y1+mid); if(fc==3) cut(a,x1,y2-mid,x1+mid,y2); if(fc==4) cut(a,x2-mid,y2-mid,x2,y2);&#125;data a;bool jud()&#123; data b; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; b.top=a.top; for(int i=1;i&lt;=b.top;i++) b.x[i]=a.x[i],b.y[i]=a.y[i]; solve(b,x);solve(b,y); int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=b.top;i++) &#123; x1=min(b.x[i],x1),x2=max(b.x[i],x2); y1=min(b.y[i],y1),y2=max(b.y[i],y2); &#125; if(x2-x1&lt;=mid&amp;&amp;y2-y1&lt;=mid)return 1; &#125; return 0;&#125;int main()&#123; int n=gi(); for(int i=1;i&lt;=n;i++)a.x[i]=gi(),a.y[i]=gi(); a.top=n; int l=1,r=inf,ans=0; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(jud())&#123;r=mid-1;ans=mid;&#125; else l=mid+1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2006 数字序列]]></title>
    <url>%2F2019%2F03%2F01%2FBZOJ1049%2F</url>
    <content type="text"><![CDATA[dp好题? 第一问第一问我会做!令$b_i=a_i-i$,求一个最长不下降子序列. $n-ans$就是最终的答案. 第二问好难啊.不会.挖坑待补. 考虑一下对于一个i~j的可能符合情况,定然存在一个$k$在i~k之中为$a_i$,k~j之中为$a_j$. 然后就可以dp了. 这个转移比较玄学.如果不随机就GG了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010;int a[N],n,L,cnt,mn[N],f[N],front[N],to[N&lt;&lt;2],nxt[N&lt;&lt;2];ll g[N],s1[N],s2[N];int find(int x)&#123; int l=1,r=L,t=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(mn[mid]&lt;=x)t=mid,l=mid+1; else r=mid-1; &#125; return t;&#125;void dp()&#123; memset(mn,127,sizeof(mn)); mn[0]=-(1&lt;&lt;30); for(int i=1;i&lt;=n;i++)&#123; int q=find(a[i]); f[i]=q+1; L=max(L,f[i]); mn[q+1]=min(mn[q+1],a[i]); &#125;&#125;void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void solve()&#123; for(int i=n;~i;i--)&#123; Add(f[i],i); g[i]=1ll&lt;&lt;60; &#125; g[0]=0;a[0]=-(1&lt;&lt;30); for(int u=1;u&lt;=n;u++) for(int i=front[f[u]-1];i;i=nxt[i])&#123; int v=to[i]; if(v&gt;u)break; if(a[v]&gt;a[u])continue; for(int j=v;j&lt;=u;j++)s1[j]=abs(a[v]-a[j]),s2[j]=abs(a[u]-a[j]); for(int j=v+1;j&lt;=u;j++) s1[j]+=s1[j-1],s2[j]+=s2[j-1]; for(int j=v;j&lt;u;j++) g[u]=min(g[u],g[v]+s1[j]-s1[v]+s2[u]-s2[j]); &#125;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi()-i; a[++n]=1&lt;&lt;30; dp();solve(); printf("%d\n%lld\n",n-f[n],g[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F2019%2F02%2F28%2FWelcome%20To%20My%20Blog%2F</url>
    <content type="text"><![CDATA[欢迎来到我的hexo博客! emmm,我也不知道自己有多少博客,但是这一次一定是最后一个了. 希望能够开的很久吧.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
