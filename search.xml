<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[上下界网络流总结]]></title>
    <url>%2F%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言最近发现网路流很菜,所以就做点题目练练手. 无源汇上下界可行流题面 我们不妨先把所有的边的容量设为$[0,upp-low]$,那么这个时候显然一条边的实际流量应该是$flow_i+low_i$对吧. 我们对于新建的图跑流,肯定是能够保证$flow_i$平衡,但是我们无法保证$flow_i+low_i$平衡,这时我们引入一个$delta$数组. 对于$delta_i$,它的值是所有出边的下界-入边的下界. 那么这个时候我们对于$delta_i&gt;0$的就只需要增加它的入边,$delta&lt;0$的增加它的出边. 这时我们引入超级源点和超级汇点,然后直接按照上述方法连边即可. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010,Inf=1e9+10;int front[N],cnt,n,m,s,t,dep[N],in[N],out[N];queue&lt;int&gt;Q;struct node&#123;int to,nxt,w;&#125;e[N&lt;&lt;1];void Add(int u,int v,int w)&#123; e[cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt++; e[cnt]=(node)&#123;u,front[v],0&#125;;front[v]=cnt++;&#125;bool bfs()&#123; Q.push(s);memset(dep,0,sizeof(dep));dep[s]=1; while(!Q.empty())&#123; int u=Q.front();Q.pop(); for(int i=front[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(!dep[v] &amp;&amp; e[i].w)&#123; dep[v]=dep[u]+1;Q.push(v); &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t || !flow)return flow; for(int i=front[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w)&#123; int di=dfs(v,min(flow,e[i].w)); if(di)&#123; e[i].w-=di;e[i^1].w+=di;return di; &#125; else dep[v]=0; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs())while(int d=dfs(s,Inf))flow+=d; return flow;&#125;int sum,Up[N];int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);#endif n=gi();m=gi();memset(front,-1,sizeof(front)); s=0;t=n+1; for(int i=1;i&lt;=m;i++)&#123; int u=gi(),v=gi(),low=gi(),upp=gi(); in[v]+=low;out[u]+=low;Up[i]=upp; Add(u,v,upp-low); &#125; for(int i=1;i&lt;=n;i++) if(in[i]&gt;out[i])&#123;Add(s,i,in[i]-out[i]);sum+=in[i]-out[i];&#125; else Add(i,t,out[i]-in[i]); int flow=Dinic(); if(flow&lt;sum)return puts("NO"),0; puts("YES"); for(int i=1;i&lt;=m;i++) printf("%d\n",Up[i]-e[(i-1)*2].w); return 0;&#125; 有源汇上下界最大流题面 还是先按照上述的方法,将$t-&gt;s$连边$\infty$保证流量平衡,然后跑出来一个可行流. 接着在残量网络上面跑$s-&gt;t$的最大流就是答案. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,Inf=1e9+10;int n,m,s,t,front[N],cnt,dep[N],ss,tt,delta[N],sum;queue&lt;int&gt;Q;struct node&#123;int to,nxt,w;&#125;e[N&lt;&lt;1];void Add(int u,int v,int w)&#123; e[cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt++; e[cnt]=(node)&#123;u,front[v],0&#125;;front[v]=cnt++;&#125;bool bfs()&#123; Q.push(ss);memset(dep,0,sizeof(dep));dep[ss]=1; while(!Q.empty())&#123; int u=Q.front();Q.pop(); for(int i=front[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(!dep[v] &amp;&amp; e[i].w)&#123; dep[v]=dep[u]+1;Q.push(v); &#125; &#125; &#125; return dep[tt];&#125;int dfs(int u,int flow)&#123; if(u==tt || !flow)return flow; for(int i=front[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w)&#123; int di=dfs(v,min(e[i].w,flow)); if(di)&#123; e[i].w-=di;e[i^1].w+=di;return di; &#125; else dep[v]=0; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs())while(int d=dfs(ss,Inf))flow+=d; return flow;&#125;int main()&#123; n=gi();m=gi();s=gi();t=gi();memset(front,-1,sizeof(front)); ss=n+1;tt=ss+1; for(int i=1;i&lt;=m;i++)&#123; int u=gi(),v=gi(),low=gi(),upp=gi(); Add(u,v,upp-low); delta[u]-=low;delta[v]+=low; &#125; for(int i=1;i&lt;=n;i++) if(delta[i]&gt;0)Add(ss,i,delta[i]),sum+=delta[i]; else Add(i,tt,-delta[i]); Add(t,s,Inf); int flow=Dinic(); if(flow&lt;sum)puts("please go home to sleep"); else&#123; ss=s;tt=t; printf("%d\n",Dinic()); &#125; return 0;&#125; 有源汇上下界最小流题面 还是先按照上述的方法,将$t-&gt;s$连边$\infty$保证流量平衡,然后跑出来一个可行流. 接着在残量网络上面跑出$t-&gt;s$的最大流.最后那可行流减去最大流就是答案. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1000010,Inf=1e9+10;int n,m,s,t,cur[N],front[N],cnt,dep[N],ss,tt,delta[N],sum;queue&lt;int&gt;Q;struct node&#123;int to,nxt,w;&#125;e[N&lt;&lt;1];void Add(int u,int v,int w)&#123; e[cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt++; e[cnt]=(node)&#123;u,front[v],0&#125;;front[v]=cnt++;&#125;bool bfs()&#123; Q.push(ss);memset(dep,0,sizeof(dep));dep[ss]=1; while(!Q.empty())&#123; int u=Q.front();Q.pop(); for(int i=front[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(!dep[v] &amp;&amp; e[i].w)&#123; dep[v]=dep[u]+1;Q.push(v); &#125; &#125; &#125; return dep[tt];&#125;int dfs(int u,int flow)&#123; if(u==tt || !flow)return flow; for(int &amp;i=cur[u];~i;i=e[i].nxt)&#123; int v=e[i].to; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w)&#123; int di=dfs(v,min(e[i].w,flow)); if(di)&#123; e[i].w-=di;e[i^1].w+=di;return di; &#125; else dep[v]=0; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs())&#123; for(int i=1;i&lt;=max(tt,n);i++)cur[i]=front[i]; while(int d=dfs(ss,Inf))flow+=d; &#125; return flow;&#125;void del(int u)&#123; for(int i=front[u];~i;i=e[i].nxt) e[i].w=e[i^1].w=0;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);#endif n=gi();m=gi();s=gi();t=gi();memset(front,-1,sizeof(front)); ss=n+1;tt=ss+1; for(int i=1;i&lt;=m;i++)&#123; int u=gi(),v=gi(),low=gi(),upp=gi(); Add(u,v,upp-low); delta[u]-=low;delta[v]+=low; &#125; for(int i=1;i&lt;=n;i++) if(delta[i]&gt;0)Add(ss,i,delta[i]),sum+=delta[i]; else Add(i,tt,-delta[i]); Add(t,s,Inf); int flow=Dinic(); if(flow&lt;sum)puts("please go home to sleep"); else&#123; flow=e[cnt-1].w; del(ss);del(tt);ss=t;tt=s;e[cnt-1].w=e[cnt-2].w=0; printf("%d\n",flow-Dinic()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网路流</tag>
        <tag>上下界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2003]逃学的小孩]]></title>
    <url>%2Fnoi2003-%E9%80%83%E5%AD%A6%E7%9A%84%E5%B0%8F%E5%AD%A9%2F</url>
    <content type="text"><![CDATA[传送门Luogu Solution考虑题目要求的就是$dis(A,B)+min(dis(A,C),dis(B,C))$，直接搞一个树的直径然后暴力枚举就好了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define int ll#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010;int n,m,front[N],cnt,dis1[N],dis2[N],vis[N];struct node&#123;int to,nxt,w;&#125;e[N&lt;&lt;1];void Add(int u,int v,int w)&#123;e[++cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt;&#125;typedef pair&lt;int,int&gt; pii;#define mp make_pairpriority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;void bfs1(int s)&#123; memset(dis1,63,sizeof(dis1));memset(vis,0,sizeof(vis)); dis1[s]=0; q.push(mp(0,s)); while(!q.empty())&#123; int u=q.top().second;q.pop(); if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(dis1[v]&gt;dis1[u]+e[i].w)&#123; dis1[v]=dis1[u]+e[i].w; q.push(mp(dis1[v],v)); &#125; &#125; &#125;&#125;void bfs2(int s)&#123; memset(dis2,63,sizeof(dis2));memset(vis,0,sizeof(vis)); dis2[s]=0; q.push(mp(0,s)); while(!q.empty())&#123; int u=q.top().second;q.pop(); if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(dis2[v]&gt;dis2[u]+e[i].w)&#123; dis2[v]=dis2[u]+e[i].w; q.push(mp(dis2[v],v)); &#125; &#125; &#125;&#125;signed main()&#123; n=gi();m=gi(); for(int i=1;i&lt;=m;i++)&#123; int u=gi(),v=gi(),w=gi(); Add(u,v,w);Add(v,u,w); &#125; bfs1(1); int mx=0,id1=0,id2=0; for(int i=1;i&lt;=n;i++) if(dis1[i]&gt;mx)&#123;mx=dis1[i];id1=i;&#125; bfs1(id1);mx=0; for(int i=1;i&lt;=n;i++) if(dis1[i]&gt;mx)&#123;mx=dis1[i];id2=i;&#125; int ans=0; bfs2(id2); for(int i=1;i&lt;=n;i++) ans=max(ans,min(dis1[i],dis2[i])); printf("%lld\n",mx+ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>树的直径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BJOI2018」求和]]></title>
    <url>%2F%E3%80%8Cbjoi2018%E3%80%8D%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution$1 \leq k \leq 50$,所以我们可以把每一种$k$的取值预处理出来,然后每一个询问树上差分就好了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=300010,Mod=998244353;int n,front[N],cnt,f[N][23],dep[N],dis[N][60];struct node&#123;int to,nxt;&#125;e[N&lt;&lt;1];int qpow(int a,int b)&#123;int ret=1;while(b)&#123;if(b&amp;1)ret=1ll*ret*a%Mod;b&gt;&gt;=1;a=1ll*a*a%Mod;&#125;return ret;&#125;void Add(int u,int v)&#123;e[++cnt]=(node)&#123;v,front[u]&#125;;front[u]=cnt;&#125;void dfs(int u,int ff)&#123; dep[u]=dep[ff]+1;f[u][0]=ff; for(int k=1;k&lt;=50;k++)dis[u][k]=(dis[ff][k]+qpow(dep[u],k))%Mod; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to;if(v==ff)continue; dfs(v,u); &#125;&#125;int getlca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=20;~i;i--) if(dep[x]-(1&lt;&lt;i)&gt;=dep[y])x=f[x][i]; if(x==y)return x; for(int i=20;~i;i--) if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; return f[x][0];&#125;int solve(int x,int y,int k)&#123; int lca=getlca(x,y); return (((dis[x][k]+dis[y][k])%Mod-dis[lca][k]+Mod)%Mod-dis[f[lca][0]][k]+Mod)%Mod;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;n;i++)&#123; int u=gi(),v=gi(); Add(u,v);Add(v,u); &#125; dep[1]=-1;dfs(1,1); f[1][0]=0; for(int j=1;j&lt;=20;j++) for(int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; int m=gi(); while(m--)&#123; int u=gi(),v=gi(),k=gi(); printf("%d\n",solve(u,v,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.25考试Solution]]></title>
    <url>%2F6-25%E8%80%83%E8%AF%95solution%2F</url>
    <content type="text"><![CDATA[前言今天考试我又垫底了….完蛋了… A Median of Medians传送门题目来源 Solution考虑可以二分,那么我们令$\leq mid$的为1,$&lt;\ mid$的为-1,然后做一个逆序对就行了.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010;int a[N],b[N],n,tot,p[N],c[N&lt;&lt;2],Mx;ll cnt;int lowbit(int x)&#123;return x&amp;(-x);&#125;void Add(int x,int d)&#123;while(x&lt;=Mx)&#123;c[x]+=d;x+=lowbit(x);&#125;&#125;int sum(int x)&#123;int ret=0;while(x)&#123;ret+=c[x];x-=lowbit(x);&#125;return ret;&#125;bool check(int mid)&#123; for(int i=1;i&lt;=n;i++) if(p[i]&lt;mid)a[i]=-1; else a[i]=1; ll ans=0; for(int i=1;i&lt;=n;i++)&#123;a[i]+=a[i-1];if(a[i]&gt;=0)ans++;&#125; memset(c,0,sizeof(c));Mx=0; for(int i=1;i&lt;=n;i++)&#123;a[i]+=n+1;Mx=max(Mx,a[i]);&#125; for(int i=1;i&lt;=n;i++)&#123; ans+=sum(a[i]); Add(a[i],1); &#125; return cnt-ans&lt;cnt/2+1;&#125;int q[100010];int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)p[i]=q[i]=gi(); sort(q+1,q+n+1);int tot=unique(q+1,q+n+1)-q-1; for(int i=1;i&lt;=n;i++)p[i]=lower_bound(q+1,q+tot+1,p[i])-q; int l=1,r=tot,ans=0;cnt=1ll*n*(n-1)/2ll+n; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))&#123;ans=mid;l=mid+1;&#125; else r=mid-1; &#125; printf("%d\n",q[ans]); return 0;&#125; B Ribbons on Tree传送门题目来源 Solution考虑容斥,然后就自己看这个博客吧.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=5010,Mod=1e9+7;int n,cnt,front[N],f[N][N][2],p[N][2],g[N],siz[N];struct node&#123;int to,nxt;&#125;e[N&lt;&lt;1];void Add(int u,int v)&#123;e[++cnt]=(node)&#123;v,front[u]&#125;;front[u]=cnt;&#125;void dfs(int u,int ff)&#123; siz[u]=1;f[u][1][0]=1; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to;if(v==ff)continue; dfs(v,u);memset(p,0,sizeof(p)); for(int j=1;j&lt;=siz[u];j++) for(int k=1;k&lt;=siz[v];k++)&#123; ll same=(1ll*f[u][j][0]*f[v][k][0]%Mod+1ll*f[u][j][1]*f[v][k][1]%Mod)%Mod; ll diff=(1ll*f[u][j][0]*f[v][k][1]%Mod+1ll*f[u][j][1]*f[v][k][0]%Mod)%Mod; p[j+k][0]=(p[j+k][0]+same)%Mod; p[j+k][1]=(p[j+k][1]+diff)%Mod; p[j][0]=(p[j][0]+1ll*g[k]*diff%Mod)%Mod; p[j][1]=(p[j][1]+1ll*g[k]*same%Mod)%Mod; &#125; siz[u]+=siz[v]; memcpy(f[u],p,sizeof(p)); &#125;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;n;i++)&#123; int u=gi(),v=gi(); Add(u,v);Add(v,u); &#125; g[0]=1; for(int i=2;i&lt;=n;i+=2)g[i]=1ll*g[i-2]*(i-1)%Mod; dfs(1,1);int ans=0; for(int i=2;i&lt;=n;i+=2) ans=(ans+1ll*(f[1][i][0]-f[1][i][1]+Mod)%Mod*g[i]%Mod)%Mod; printf("%d\n",ans); return 0;&#125; C Robots and Exits传送门题目来源 Solution考虑抽象一下每一个点,令$a_i$表示到左边的距离,$b_i$表示到右边的距离,然后轮廓线搞一下就好了. 注意不去重可能会导致重复计算贡献.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,Mod=1e9+7;int n,m,a[N],b[N],d[N],C[N],cnt,tot;typedef pair&lt;int,int&gt; pii;#define mp make_pairpii c[N];int lowbit(int x)&#123;return x&amp;(-x);&#125;void Add(int x,ll d)&#123;while(x&lt;=cnt)&#123;C[x]=(C[x]+d)%Mod;x+=lowbit(x);&#125;&#125;ll sum(int x)&#123; ll ret=0; while(x)&#123;ret=(ret+C[x])%Mod;x-=lowbit(x);&#125; return ret;&#125;bool cmp(pii a,pii b)&#123; return a.first&lt;b.first || (a.first==b.first &amp;&amp; a.second&gt;b.second);&#125;int main()&#123; n=gi();m=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); for(int i=1;i&lt;=m;i++)b[i]=gi(); for(int i=1;i&lt;=n;i++) if(a[i]&gt;b[1] &amp;&amp; a[i]&lt;b[m])&#123; int x=lower_bound(b+1,b+m+1,a[i])-b; if(b[x]==a[i])continue; c[++tot]=mp(a[i]-b[x-1],b[x]-a[i]); d[tot]=b[x]-a[i]; &#125; sort(d+1,d+tot+1);cnt=unique(d+1,d+tot+1)-d-1; for(int i=1;i&lt;=tot;i++) c[i].second=lower_bound(d+1,d+cnt+1,c[i].second)-d; sort(c+1,c+tot+1,cmp);tot=unique(c+1,c+tot+1)-c-1; ll ans=1; for(int i=1;i&lt;=tot;i++)&#123; ll fi=sum(c[i].second-1)+1; ans=(ans+fi)%Mod; Add(c[i].second,fi); &#125; printf("%lld\n",ans); return 0;&#125; D E放代码不写题解,过于麻瓜… D123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define int ll#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010;int n,m,d[N],a[N],b[N];struct node&#123;int day,id;&#125;exam[N];bool operator&lt;(const node a,const node b)&#123; return a.day&lt;b.day;&#125;bool check(int mid)&#123; for(int i=1;i&lt;=m;i++)exam[i]=(node)&#123;0,i&#125;,b[i]=0; for(int i=1;i&lt;=mid;i++) if(d[i])&#123;exam[d[i]]=(node)&#123;max(i,exam[d[i]].day),d[i]&#125;;b[d[i]]=1;&#125; for(int i=1;i&lt;=m;i++)if(!b[i])return false; sort(exam+1,exam+m+1); int sum=0; for(int i=1;i&lt;=m;i++)&#123; sum+=exam[i].day-exam[i-1].day-1; int j=exam[i].id; if(sum&gt;=a[j])&#123;sum-=a[j];continue;&#125; return false; &#125; return true;&#125;signed main()&#123; ///Orz Orz Orz hyj!!! n=gi();m=gi(); for(int i=1;i&lt;=n;i++)d[i]=gi(); for(int i=1;i&lt;=m;i++)a[i]=gi(); int l=1,r=n,ans=-1; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))&#123;r=mid-1;ans=mid;&#125; else l=mid+1; &#125; printf("%lld\n",ans); return 0;&#125; E123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin)//;freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010;int front[N],cnt,lev[N],tot,f[N][20],dep[N],n,s,k,b[N];struct node&#123;int to,nxt;&#125;e[N&lt;&lt;1];void Add(int u,int v)&#123;e[++cnt]=(node)&#123;v,front[u]&#125;;front[u]=cnt;&#125;void dfs(int u,int ff)&#123; dep[u]=dep[ff]+1;f[u][0]=ff;int flag=0; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to;if(v==ff)continue; flag=1;dfs(v,u); &#125; if(!flag)lev[++tot]=u;&#125;struct leave&#123; int id,dep; bool operator&lt;(const leave b)const&#123;return dep&gt;b.dep;&#125;&#125;p[N];int lca(int x,int y)&#123; if(dep[x]&lt;dep[y])swap(x,y); for(int i=18;~i;i--) if(dep[x]-(1&lt;&lt;i)&gt;=dep[y])x=f[x][i]; if(x==y)return x; for(int i=18;~i;i--) if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i]; return f[x][0];&#125;int dis(int x,int y)&#123;return dep[x]+dep[y]-2*dep[lca(x,y)];&#125;int main()&#123; int T=gi(); while(T--)&#123; n=gi();s=gi();k=gi();k=min(k,n);tot=0; memset(front,0,sizeof(front));cnt=0; for(int i=1;i&lt;n;i++)&#123; int u=gi(),v=gi(); Add(u,v);Add(v,u); &#125; dep[s]=-1;dfs(s,s);cnt=0; for(int j=1;j&lt;=18;j++) for(int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; for(int i=1;i&lt;=tot;i++) if(dep[lev[i]]&gt;k)&#123; p[++cnt]=(leave)&#123;lev[i],dep[lev[i]]&#125;; &#125; sort(p+1,p+cnt+1);int ans=0; for(int i=1;i&lt;=cnt;i++)if(!b[i])&#123; int u=p[i].id,len=0; while(u &amp;&amp; len&lt;k)&#123;u=f[u][0];len++;&#125; b[i]=1; for(int j=1;j&lt;=cnt;j++) if(!b[j] &amp;&amp; dis(u,p[j].id)&lt;=k)b[j]=1; ans++; &#125; printf("%d\n",ans); for(int i=1;i&lt;=n;i++)b[i]=0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO17JAN]Promotion Counting晋升者计数]]></title>
    <url>%2Fusaco17jan-promotion-counting%E6%99%8B%E5%8D%87%E8%80%85%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[传送门洛谷 Solution直接线段树合并然后遍历整棵树就好了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,Inf=1e9;struct node&#123;int to,nxt;&#125;e[N];int cnt,front[N],ans[N];void Add(int u,int v)&#123;e[++cnt]=(node)&#123;v,front[u]&#125;;front[u]=cnt;&#125;struct tree&#123;int ls,rs,sum;&#125;t[N*32];int tot;int rt[N],p[N],n;int merge(int u,int v)&#123; if(!u || !v)return u+v; int now=++tot; t[now].sum=t[u].sum+t[v].sum; t[now].ls=merge(t[u].ls,t[v].ls); t[now].rs=merge(t[u].rs,t[v].rs); return now;&#125;int query(int o,int l,int r,int pos)&#123; if(!o)return 0; if(pos&lt;=l)return t[o].sum; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)return query(t[o].rs,mid+1,r,pos)+query(t[o].ls,l,mid,pos); else return query(t[o].rs,mid+1,r,pos);&#125;void modify(int&amp;o,int l,int r,int pos)&#123; if(!o)o=++tot; t[o].sum++; if(l==r)return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid)modify(t[o].ls,l,mid,pos); else modify(t[o].rs,mid+1,r,pos);&#125;void dfs(int u)&#123; for(int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to; dfs(v); rt[u]=merge(rt[u],rt[v]); &#125; ans[u]=query(rt[u],1,Inf,p[u]+1); modify(rt[u],1,Inf,p[u]);&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)p[i]=gi(); for(int i=2;i&lt;=n;i++)Add(gi(),i); dfs(1); for(int i=1;i&lt;=n;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Lydsy1704月赛]最小公倍佩尔数]]></title>
    <url>%2Flydsy1704%E6%9C%88%E8%B5%9B-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E4%BD%A9%E5%B0%94%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[[PA2014]Muzeum]]></title>
    <url>%2Fpa2014-muzeum%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solution显然这是一个最大权闭合子图的问题,所以你把图建出来跑网络流就是$50pts$.接着你旋转坐标系然后把这个转换成为一个贪心替换网络流的问题,然后就是一个$set$的事了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=5010,Inf=1e9+10;struct thing&#123; int x,y,v;&#125;p[N],q[N];int n,m,w,h,front[N],cnt,s,t,dep[N];struct node&#123; int to,nxt,w;&#125;e[6000010];void Add(int u,int v,int w)&#123;e[cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt++;e[cnt]=(node)&#123;u,front[v],0&#125;;front[v]=cnt++;&#125;queue&lt;int&gt;Q;bool bfs()&#123; Q.push(s);memset(dep,0,sizeof(dep));dep[s]=1; while(!Q.empty()) &#123; int u=Q.front();Q.pop(); for(int i=front[u];i!=-1;i=e[i].nxt) &#123; int v=e[i].to; if(!dep[v] &amp;&amp; e[i].w) &#123; dep[v]=dep[u]+1; Q.push(v); &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t || !flow)return flow; for(int i=front[u];i!=-1;i=e[i].nxt) &#123; int v=e[i].to; if(dep[v]==dep[u]+1 &amp;&amp; e[i].w) &#123; int di=dfs(v,min(flow,e[i].w)); if(di) &#123; e[i].w-=di;e[i^1].w+=di; return di; &#125; else dep[v]=0; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs()) while(int d=dfs(s,Inf)) flow+=d; return flow;&#125;bool bein(int i,int j)&#123;return 1ll*abs(p[j].x-q[i].x)*h&lt;=1ll*w*abs(p[j].y-q[i].y);&#125;namespace Accepted&#123; #define int ll const int N=500010; struct node &#123; int x,y,v; bool operator&lt;(const node b)const&#123;return x&lt;b.x;&#125; &#125;p[N],q[N]; typedef pair&lt;int,int&gt; pii; set&lt;pii&gt;se; #define mp make_pair void main() &#123; n=gi();m=gi();w=gi();h=gi();int ans=0; for(int i=1;i&lt;=n;i++)&#123;int x=1ll*gi()*h,y=1ll*gi()*w,v=gi();p[i].x=x+y;p[i].y=x-y;p[i].v=v;ans+=v;&#125; for(int i=1;i&lt;=m;i++)&#123;int x=1ll*gi()*h,y=1ll*gi()*w,v=gi();q[i].x=x+y;q[i].y=x-y;q[i].v=v;&#125; sort(p+1,p+n+1); sort(q+1,q+m+1); int pos=1; for(int i=1;i&lt;=m;i++) &#123; while(pos&lt;=n &amp;&amp; p[pos].x&lt;=q[i].x)se.insert(mp(p[pos].y,p[pos].v)),pos++; set&lt;pii&gt;::iterator it=se.lower_bound(mp(q[i].y,0));int flow=q[i].v; while(flow &amp;&amp; it!=se.end()) &#123; pii now=*it;se.erase(it); int d=min(flow,now.second); now.second-=d;ans-=d;flow-=d; if(now.second)se.insert(now); else it=se.lower_bound(mp(q[i].y,0)); &#125; &#125; printf("%lld\n",ans); return; &#125;&#125;signed main()&#123;/* ll ans=0; n=gi();m=gi();memset(front,-1,sizeof(front));s=0;t=n+m+1; w=gi();h=gi(); for(int i=1;i&lt;=n;i++)p[i].x=gi(),p[i].y=gi(),p[i].v=gi(),Add(s,i,p[i].v),ans+=p[i].v; for(int i=1;i&lt;=m;i++)q[i].x=gi(),q[i].y=gi(),q[i].v=gi(),Add(i+n,t,q[i].v); for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(q[i].y&gt;=p[j].y &amp;&amp; bein(i,j))Add(j,i+n,Inf); printf("%lld\n",ans-Dinic());*/ Accepted::main(); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2015]概率论]]></title>
    <url>%2Ftjoi2015-%E6%A6%82%E7%8E%87%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[传送门LojBZOJ Solution我们考虑一下设$f(x)$表示当$n$为$x$时构造二叉树的方案数,$g(x)$表示当$n$为$x$时构造二叉树的叶子节点数的总和.仔细看一下这个句子:当n为x时构造二叉树的方案数.$Catalan$数无疑了,接着就是解决$g(x)$是什么.现在不是有$g(x)$个叶子对吧,那么我们把这些叶子分别删掉,那么就是$g(x)$个$n-1$的节点的树.然后算上贡献就是$f(x-1)*x$对吧.接着你可以写出一个式子: $Ans=\frac{(2n-2)!n!(n+1)!}{(2n)!(n-1)!n!}=\frac{n(n+1)}{2*(2n-1)}$ 代码实现1234567891011121314151617181920212223242526272829303132/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline ll gl()&#123; ll f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;ll n;int main()&#123; n=gl(); printf("%.9lf\n",n*(n+1)*1./((2*n-1)*2)); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2008]下落的圆盘]]></title>
    <url>%2Fhaoi2008-%E4%B8%8B%E8%90%BD%E7%9A%84%E5%9C%86%E7%9B%98%2F</url>
    <content type="text"><![CDATA[传送门Luogu Solution想一想,我们求一下每一个圆没被后面的覆盖的面积加起来就是答案.每一个求的话可以求后面的后一个圆与它的交集,然后做一个线段覆盖.没了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1010;struct node&#123; double r,x,y; void gi()&#123;scanf("%lf%lf%lf",&amp;r,&amp;x,&amp;y);&#125;&#125;p[N];const double Pi=acos(-1.0);struct line&#123;double l,r;&#125;q[N&lt;&lt;2];int n,tot;double dis(int x,int y)&#123;return sqrt((p[x].x-p[y].x)*(p[x].x-p[y].x)+(p[x].y-p[y].y)*(p[x].y-p[y].y));&#125;bool contain(int i,int j)&#123;double d=dis(i,j);return p[j].r-p[i].r&gt;=d;&#125;//i被j包含bool out(int i,int j)&#123;double d=dis(i,j);return p[j].r+p[i].r&lt;=d;&#125;//外切或外离bool cmp(line a,line b)&#123;return a.l&lt;b.l;&#125;double solve(int id)&#123; tot=0; for(int i=id+1;i&lt;=n;i++)if(contain(id,i))return 0.0; for(int i=id+1;i&lt;=n;i++) &#123; if(contain(i,id) || out(i,id))continue; double d=dis(i,id); double t=acos((d*d+p[id].r*p[id].r-p[i].r*p[i].r)*1./(2.0*p[id].r*d)); double jz=atan2(p[i].y-p[id].y,p[i].x-p[id].x); q[++tot]=(line)&#123;jz-t,jz+t&#125;; if(q[tot].l&lt;0)q[tot].l+=2*Pi;if(q[tot].r&lt;0)q[tot].r+=2*Pi; if(q[tot].l&gt;q[tot].r)&#123;double R=q[tot].r;q[tot].r=2*Pi;q[++tot]=(line)&#123;0,R&#125;;&#125; &#125; sort(q+1,q+tot+1,cmp);//线段覆盖 double ret=0,now=0; for(int i=1;i&lt;=tot;i++) &#123; if(q[i].l&gt;now)&#123;ret+=q[i].l-now;now=q[i].r;&#125; else now=max(now,q[i].r); &#125; ret+=2*Pi-now; return ret*p[id].r;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("circle.in","r",stdin);#endif n=gi(); for(int i=1;i&lt;=n;i++)p[i].gi(); double ans=0; for(int i=1;i&lt;=n;i++)ans+=solve(i); printf("%.3lf\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2019]大中锋的游乐场]]></title>
    <url>%2Ftjoi2019-%E5%A4%A7%E4%B8%AD%E9%94%8B%E7%9A%84%E6%B8%B8%E4%B9%90%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution我们设$dp_{i,j,k}$表示当前到了$i$这个节点,两个的差为$j$,大一点的是$k$,然后SPFA转移就好了.其实也可以直接设$dp_{i,j}$,然后$j \in [-k,k]$.没了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=10010,M=100010;struct node&#123; int to,nxt,w;&#125;e[M&lt;&lt;1];int front[N],cnt,dp[N][20][2],bl[N],n,m,k,s,t,flag;void Add(int u,int v,int w)&#123;e[++cnt]=(node)&#123;v,front[u],w&#125;;front[u]=cnt;&#125;void clear()&#123;memset(front,0,sizeof(front));cnt=0;flag=0;&#125;typedef pair&lt;int,int&gt; pii;typedef pair&lt;int,pii&gt; piii;#define mp make_pairqueue&lt;piii&gt;Q;int vis[N][20][2];void spfa(int s)&#123; memset(dp,127/2,sizeof(dp)); dp[s][1][bl[s]]=0; Q.push(mp(s,mp(1,bl[s]))); while(!Q.empty()) &#123; piii now=Q.front();Q.pop();int u=now.first;vis[u][now.second.first][now.second.second]=0; if(u==t)flag=1; for(int i=front[u];i;i=e[i].nxt) &#123; int v=e[i].to,cha,Max; if(!now.second.first)cha=1,Max=bl[v]; else if(now.second.second==bl[v])cha=now.second.first+1,Max=now.second.second; else cha=now.second.first-1,Max=now.second.second; if(cha&gt;k)continue; if(dp[v][cha][Max]&gt;dp[u][now.second.first][now.second.second]+e[i].w) &#123; dp[v][cha][Max]=dp[u][now.second.first][now.second.second]+e[i].w; if(!vis[v][cha][Max])&#123;vis[v][cha][Max]=1;Q.push(mp(v,mp(cha,Max)));&#125; &#125; if(!cha) &#123; Max^=1; if(dp[v][cha][Max]&gt;dp[u][now.second.first][now.second.second]+e[i].w) &#123; dp[v][cha][Max]=dp[u][now.second.first][now.second.second]+e[i].w; if(!vis[v][cha][Max])&#123;vis[v][cha][Max]=1;Q.push(mp(v,mp(cha,Max)));&#125; &#125; &#125; &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("park.in","r",stdin);#endif int T=gi(); while(T--) &#123; clear(); n=gi();m=gi();k=gi(); for(int i=1;i&lt;=n;i++)bl[i]=gi()-1; for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi(),w=gi(); Add(u,v,w);Add(v,u,w); &#125; s=gi(),t=gi(); spfa(s);int ans=1e9+10; if(!flag)&#123;puts("-1");continue;&#125; for(int i=0;i&lt;=k;i++) ans=min(ans,min(dp[t][i][0],dp[t][i][1])); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SNOI2019]通信]]></title>
    <url>%2Fsnoi2019-%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution考虑拆点,然后如果连向指挥中心就是向自己的另一个定点连边.连完之后跑一个$KM$就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=2001;int n,W,a[N],visx[N],visy[N],bl[N],bly[N];ll slack[N],lx[N],w[N][N],ly[N];vector&lt;int&gt;G[N];inline bool dfs(re int x)&#123; visx[x]=1; for(re int i=0;i&lt;G[x].size();i++) &#123; re int y=G[x][i]; if(!visy[y]) &#123; ll t=lx[x]+ly[y]-w[x][y]; if(!t) &#123; visy[y]=1; if(!bl[y] || dfs(bl[y])) &#123; bl[y]=x;bly[x]=y; return true; &#125; &#125; else if(t&gt;0) &#123; slack[y]=min(slack[y],t); &#125; &#125; &#125; return false;&#125;inline ll KM()&#123; memset(ly,0,sizeof(ly)); ll ans=0; for(re int i=1;i&lt;=n;i++) &#123; memset(slack,127,sizeof(slack)); while(1) &#123; for(re int j=1;j&lt;=n;j++)visx[j]=0; for(re int j=1;j&lt;=n&lt;&lt;1;j++)visy[j]=0; if(dfs(i))break; ll Minz=1e18; for(re int j=1;j&lt;=n&lt;&lt;1;j++) if(!visy[j])Minz=min(Minz,slack[j]); for(re int j=1;j&lt;=n;j++)if(visx[j])lx[j]-=Minz; for(re int j=1;j&lt;=n&lt;&lt;1;j++)if(visy[j])ly[j]+=Minz;else slack[j]-=Minz; &#125; &#125; for(re int i=1;i&lt;=n;i++) ans+=w[i][bly[i]]; return ans;&#125;int main()&#123; n=gi();W=gi(); for(re int i=1;i&lt;=n;i++) &#123; a[i]=gi(); G[i].push_back(i+n); lx[i]=w[i][i+n]=-W; for(re int j=1;j&lt;i;j++) &#123; w[i][j]=-abs(a[i]-a[j]); G[i].push_back(j); lx[i]=max(lx[i],w[i][j]); &#125; &#125; printf("%lld\n",-KM()); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>KM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2019]甲苯先生的字符串]]></title>
    <url>%2Ftjoi2019-%E7%94%B2%E8%8B%AF%E5%85%88%E7%94%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution简单题.设$dp_{i,j}$表示当前考虑到了第$i$位,当前这一位选$j$+&#39;a&#39;这个元素.转移就随便写了,然后这个可以矩阵快速幂.P.S:唯一需要注意的就是这道题目相邻的定义为$i$和$i+1$,$i$-&gt;$i-1$不算! 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int Mod=1e9+7;ll n;struct matrix&#123; int a[26][26]; int *operator[](int x)&#123;return a[x];&#125; matrix operator*(matrix b) &#123; matrix c; for(re int i=0;i&lt;26;i++) for(re int j=0;j&lt;26;j++) &#123; c[i][j]=0; for(re int k=0;k&lt;26;k++) c[i][j]=(c[i][j]+1ll*a[i][k]*b[k][j]%Mod)%Mod; &#125; return c; &#125;&#125;S,T;char s[100010];int main()&#123; scanf("%lld",&amp;n); scanf("%s",s+1);int len=strlen(s+1); for(re int i=0;i&lt;26;i++) &#123; S[0][i]=1; for(re int j=0;j&lt;26;j++)T[i][j]=1; &#125; for(int i=1;i&lt;len;i++)T[s[i]-'a'][s[i+1]-'a']=0;--n; while(n) &#123; if((n&amp;1ll))S=S*T; T=T*T;n&gt;&gt;=1ll; &#125; int ans=0; for(re int i=0;i&lt;26;i++)ans=(ans+S[0][i])%Mod; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2019]甲苯先生的滚榜]]></title>
    <url>%2Ftjoi2019-%E7%94%B2%E8%8B%AF%E5%85%88%E7%94%9F%E7%9A%84%E6%BB%9A%E6%A6%9C%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution直接用$pb_ds$的红黑树或者自己手写一颗平衡树就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;using namespace __gnu_pbds;using namespace std;#define re register#define ll long longconst int N=100010;inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;typedef unsigned int ui;ui seed,last=7;int n,m;ui randNum()&#123;seed = seed * 17 + last ; return seed % m + 1; &#125;typedef pair&lt;int,int&gt; pii;typedef pair&lt;pii,int&gt; piii;tree&lt;pair&lt;pair&lt;int, int&gt;, int&gt;, null_type, greater&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; se;pii p[N];#define ac first#define Time second#define mp make_pairint main()&#123; int T=gi(); while(T--) &#123; m=gi();n=gi();scanf("%u",&amp;seed); se.clear(); for(int i=1;i&lt;=m;i++) se.insert(mp(p[i],i)); for(int i=1;i&lt;=n;i++) &#123; ui Ria=randNum(); ui Rib=randNum(); se.erase(mp(p[Ria],Ria)); p[Ria].ac++;p[Ria].Time-=Rib; se.insert(mp(p[Ria],Ria)); last=se.order_of_key(mp(p[Ria],m+1)); printf("%d\n",last); &#125; for(int i=1;i&lt;=m;i++)p[i].ac=0,p[i].Time=0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[TJOI2019]甲苯先生和大中锋的字符串]]></title>
    <url>%2Ftjoi2019-%E7%94%B2%E8%8B%AF%E5%85%88%E7%94%9F%E5%92%8C%E5%A4%A7%E4%B8%AD%E9%94%8B%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[传送门Loj 吐槽要是我生在$TJ$多好啊…这种字符串模板题在湖南是见不着的啊! Solution如果大家没有做过这道题目,推荐… 那么问题就在于如何求子串长度出现次数最多的长度数（如果有多个输出最长长度）.差分就好了啊…. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010;struct node&#123; int ff,son[26],len;&#125;t[N&lt;&lt;2];int a[N&lt;&lt;2],c[N&lt;&lt;2],siz[N&lt;&lt;2],tot=1,last=1,n;void newnode(int x)&#123;t[x].ff=t[x].len=0;memset(t[x].son,0,sizeof(t[x].son));&#125;void extend(int c)&#123; int np=++tot,p=last;last=tot; t[np].len=t[p].len+1; while(p &amp;&amp; !t[p].son[c])t[p].son[c]=np,p=t[p].ff; if(!p)t[np].ff=1; else &#123; int q=t[p].son[c]; if(t[p].len+1==t[q].len)t[np].ff=q; else &#123; int nq=++tot; t[nq]=t[q];t[nq].len=t[p].len+1; t[np].ff=t[q].ff=nq; while(p &amp;&amp; t[p].son[c]==q)t[p].son[c]=nq,p=t[p].ff; &#125; &#125; siz[np]=1;&#125;char s[N];int k,ans[N];int main()&#123; int T=gi(); while(T--) &#123; scanf("%s%d",s+1,&amp;k);n=strlen(s+1);tot=last=1;newnode(1); for(int i=1;i&lt;=n;i++)extend(s[i]-'a'); for(int i=1;i&lt;=tot;i++)c[t[i].len]++; for(int i=1;i&lt;=n;i++)c[i]+=c[i-1]; for(int i=1;i&lt;=tot;i++)a[c[t[i].len]--]=i; for(int i=tot;i;i--) &#123; int now=a[i]; siz[t[now].ff]+=siz[now]; if(siz[now]==k &amp;&amp; now!=1)ans[t[t[now].ff].len+1]++,ans[t[now].len+1]--; &#125; for(int i=1;i&lt;=n;i++)ans[i]+=ans[i-1]; int p=0; for(int i=n;i;i--)if(ans[i]&gt;ans[p])p=i;if(!p)p=-1; printf("%d\n",p); for(int i=1;i&lt;=n;i++)ans[i]=0,c[i]=0; for(int i=1;i&lt;=tot;i++) &#123; siz[i]=0; memset(t[i].son,0,sizeof(t[i].son)); t[i].len=t[i].ff=0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SNOI2019]字符串]]></title>
    <url>%2Fsnoi2019-%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution我们在脑子里面构想一下怎么判断两个串的大小,发现就是两个相邻后缀的$lcp$.令串为$a$和$b$如果长度超过$a,b$之间的长度,那么就是$id$的大小,否则就是看不匹配的那位的大小. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1000010;int lcp[N],n,f[N];char s[N];bool cmp(int a,int b)&#123; int big=1;if(a&gt;b)swap(a,b),big=0; if(lcp[a+1]&gt;=b-a)return big; return big^(s[a+lcp[a+1]+1]&gt;s[a+lcp[a+1]]);&#125;int main()&#123; n=gi();scanf("%s",s+1); for(int i=2;i&lt;=n;i++) &#123; lcp[i]=max(lcp[i-1]-1,0); while(i+lcp[i]&lt;=n &amp;&amp; s[i+lcp[i]]==s[i+lcp[i]-1])lcp[i]++; &#125; for(int i=1;i&lt;=n;i++)f[i]=i; sort(f+1,f+n+1,cmp); for(int i=1;i&lt;=n;i++)printf("%d%c",f[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[To Do List]]></title>
    <url>%2Fto-do-list%2F</url>
    <content type="text"><![CDATA[省份 T1 T2 T3 T4 T5 T6 ZJOI $\surd$ HNOI $\surd$ 十二省 GX/GZOI $\surd$ $\surd$ $\surd$ $\surd$ $\surd$ $\surd$ BJOI SNOI $\surd$ $\surd$ TJOI $\surd$ $\surd$ $\surd$ $\surd$]]></content>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]旧词]]></title>
    <url>%2Fgxoi-gzoi2019-%E6%97%A7%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution我们先想一下答案怎么转换(如果$k=1$)?把$y$到根节点的路径打上标记,答案就是$i \leq x$到根节点的路径的标记总数.这个又可以变成:$i \leq x$到根节点的路径打标记,然后$y$到根节点的标记总数.然后如果$k!=1$,也可以差分就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010,Mod=998244353;struct node&#123;int to,nxt;&#125;e[N&lt;&lt;1];struct ques&#123;int x,y,id;&#125;q[N];int front[N],cnt,dep[N],fa[N],siz[N],son[N],dfn[N],top[N],Time,n,Q,k,id[N],sum[N];int qpow(int a,int b)&#123;int ret=1;while(b)&#123;if(b&amp;1)ret=1ll*ret*a%Mod;a=1ll*a*a%Mod;b&gt;&gt;=1;&#125;return ret;&#125;void Add(int u,int v)&#123;e[++cnt]=(node)&#123;v,front[u]&#125;;front[u]=cnt;&#125;bool cmp(ques a,ques b)&#123;return a.x&lt;b.x;&#125;void dfs1(int u,int ff)&#123; dep[u]=dep[ff]+1;siz[u]=1; for(int i=front[u];i;i=e[i].nxt) &#123; int v=e[i].to; dfs1(v,u); siz[u]+=siz[v]; if(siz[son[u]]&lt;siz[v])son[u]=v; &#125;&#125;void dfs2(int u,int tp)&#123; dfn[u]=++Time;top[u]=tp;id[dfn[u]]=u; if(!son[u])return; dfs2(son[u],tp); for(int i=front[u];i;i=e[i].nxt) &#123; int v=e[i].to;if(v==son[u])continue; dfs2(v,v); &#125;&#125;struct Tree&#123;int sum,atag;&#125;t[N&lt;&lt;2];void pushup(int x)&#123; t[x].sum=(t[x&lt;&lt;1].sum+t[x&lt;&lt;1|1].sum)%Mod;&#125;void pushdown(int x,int l,int r)&#123; if(t[x].atag) &#123; int mid=(l+r)&gt;&gt;1; t[x&lt;&lt;1].sum=(t[x&lt;&lt;1].sum+1ll*t[x].atag*((sum[mid]-sum[l-1]+Mod)%Mod)%Mod)%Mod; t[x&lt;&lt;1|1].sum=(t[x&lt;&lt;1|1].sum+1ll*t[x].atag*((sum[r]-sum[mid]+Mod)%Mod)%Mod)%Mod; t[x&lt;&lt;1].atag+=t[x].atag;t[x&lt;&lt;1|1].atag+=t[x].atag; t[x].atag=0; &#125;&#125;void modify(int o,int l,int r,int posl,int posr)&#123; if(posl&lt;=l &amp;&amp; r&lt;=posr) &#123; t[o].sum=((t[o].sum+sum[r])%Mod-sum[l-1]+Mod)%Mod; t[o].atag++; return; &#125; int mid=(l+r)&gt;&gt;1;pushdown(o,l,r); if(posl&lt;=mid)modify(o&lt;&lt;1,l,mid,posl,posr); if(mid&lt;posr)modify(o&lt;&lt;1|1,mid+1,r,posl,posr); pushup(o);&#125;int query(int o,int l,int r,int posl,int posr)&#123; if(posl&lt;=l &amp;&amp; r&lt;=posr)return t[o].sum; int mid=(l+r)&gt;&gt;1,s=0;pushdown(o,l,r); if(posl&lt;=mid)s=query(o&lt;&lt;1,l,mid,posl,posr); if(mid&lt;posr)s=(s+query(o&lt;&lt;1|1,mid+1,r,posl,posr))%Mod; return s;&#125;void Modify(int x)&#123; while(x) &#123; modify(1,1,n,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125;&#125;int Query(int x)&#123; int ret=0; while(x) &#123; ret=(ret+query(1,1,n,dfn[top[x]],dfn[x]))%Mod; x=fa[top[x]]; &#125; return ret;&#125;int ans[N];int main()&#123; freopen("poetry.in","r",stdin); freopen("poetry.out","w",stdout); n=gi();Q=gi();k=gi(); for(int i=2;i&lt;=n;i++)fa[i]=gi(),Add(fa[i],i); for(int i=1;i&lt;=Q;i++)q[i].x=gi(),q[i].y=gi(),q[i].id=i; sort(q+1,q+Q+1,cmp); dfs1(1,1);dfs2(1,1); for(int i=1;i&lt;=n;i++)sum[i]=(sum[i-1]+(qpow(dep[id[i]],k)-qpow(dep[id[i]]-1,k)+Mod)%Mod)%Mod; int pos=1; for(int i=1;i&lt;=Q;i++) &#123; while(pos&lt;=q[i].x) &#123; Modify(pos);pos++; &#125; ans[q[i].id]=Query(q[i].y); &#125; for(int i=1;i&lt;=Q;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]旅行者]]></title>
    <url>%2Fgxoi-gzoi2019-%E6%97%85%E8%A1%8C%E8%80%85%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution考虑两个关键点对之间一定不会经过另一个关键点,那么就跑两边$dijkstra$然后枚举边就行了.具体实现见代码. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define int ll#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010,M=1000010;struct node&#123; int to,nxt,w,id;&#125;e[M];struct edge&#123;int u,v,w;&#125;ed[M&lt;&lt;1];int front[N],cnt=1,a[N],bl[N][2],n,m,k,vis[N];ll dis[N][2];void Add(int u,int v,int w)&#123;e[++cnt]=(node)&#123;v,front[u],w,0&#125;;front[u]=cnt;e[++cnt]=(node)&#123;u,front[v],w,1&#125;;front[v]=cnt;&#125;typedef pair&lt;ll,int&gt; pii;priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;#define mp make_pairvoid solve()&#123; ll ans=1e18+10; for(int i=1;i&lt;=n;i++)dis[i][0]=1e18,vis[i]=0; for(int i=1;i&lt;=k;i++)dis[a[i]][0]=0,bl[a[i]][0]=a[i],q.push(mp(0,a[i])); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=e[i].nxt) &#123; if(e[i].id)continue; int v=e[i].to; if(dis[v][0]&gt;dis[u][0]+e[i].w) &#123; dis[v][0]=dis[u][0]+e[i].w; q.push(mp(dis[v][0],v)); bl[v][0]=bl[u][0]; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)dis[i][1]=1e18,vis[i]=0; for(int i=1;i&lt;=k;i++)dis[a[i]][1]=0,bl[a[i]][1]=a[i],q.push(mp(0,a[i])); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=e[i].nxt) &#123; if(!e[i].id)continue; int v=e[i].to; if(dis[v][1]&gt;dis[u][1]+e[i].w) &#123; dis[v][1]=dis[u][1]+e[i].w; q.push(mp(dis[v][1],v)); bl[v][1]=bl[u][1]; &#125; &#125; &#125; for(int i=1;i&lt;=m;i++) &#123; int u=ed[i].u,v=ed[i].v; if(bl[u][0]==bl[v][1])continue; ans=min(ans,ed[i].w+dis[u][0]+dis[v][1]); &#125; printf("%lld\n",ans);&#125;signed main()&#123; freopen("tourist.in","r",stdin); freopen("tourist.out","w",stdout); int T=gi(); while(T--) &#123; n=gi();m=gi();k=gi(); for(int i=1;i&lt;=m;i++)&#123;int x=gi(),y=gi(),z=gi();Add(x,y,z);ed[i]=(edge)&#123;x,y,z&#125;;&#125; for(int i=1;i&lt;=k;i++)a[i]=gi(); solve(); for(int i=1;i&lt;=n;i++)front[i]=0;cnt=1; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]逼死强迫症]]></title>
    <url>%2Fgxoi-gzoi2019-%E9%80%BC%E6%AD%BB%E5%BC%BA%E8%BF%AB%E7%97%87%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution比较简单.考虑设$f_i$表示当$N$为$i$的时候的答案,$g_i$表示只用1*2的铺满$2*i$格子的方案数.有:$f_i=f_{i-1}+f_{i-2}+2*\sum_{j=1}^{i-3}g_j$然后我们又知道斐波那契数列的前缀和$s_i$=$g_i+2$,直接矩阵快速幂就好了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int Mod=1e9+7;struct matrix&#123; int a[5][5];&#125;S,T;matrix cheng(matrix a,matrix b)&#123; matrix c; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;5;j++) &#123; c.a[i][j]=0; for(int k=0;k&lt;5;k++) c.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j]%Mod)%Mod; &#125; return c;&#125;int main()&#123; freopen("obsession.in","r",stdin); freopen("obsession.out","w",stdout); int Case=gi(); while(Case--) &#123; int n=gi(); S.a[0][0]=0;S.a[0][1]=0;S.a[0][2]=1;S.a[0][3]=2;S.a[0][4]=2; T.a[0][0]=0;T.a[0][1]=1;T.a[0][2]=0;T.a[0][3]=0;T.a[0][4]=0; T.a[1][0]=1;T.a[1][1]=1;T.a[1][2]=0;T.a[1][3]=0;T.a[1][4]=0; T.a[2][0]=0;T.a[2][1]=0;T.a[2][2]=0;T.a[2][3]=1;T.a[2][4]=0; T.a[3][0]=0;T.a[3][1]=2;T.a[3][2]=1;T.a[3][3]=1;T.a[3][4]=0; T.a[4][0]=0;T.a[4][1]=Mod-1;T.a[4][2]=0;T.a[4][3]=0;T.a[4][4]=1; if(n==1)&#123;puts("0");continue;&#125; n-=2; while(n) &#123; if(n&amp;1)S=cheng(S,T); T=cheng(T,T);n&gt;&gt;=1; &#125; printf("%d\n",S.a[0][1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GX|GZOI2019]]></title>
    <url>%2Fgx-gzoi2019%2F</url>
    <content type="text"><![CDATA[没有摘要 戳我看总结]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>省选题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]特技飞行]]></title>
    <url>%2Fgxoi-gzoi2019-%E7%89%B9%E6%8A%80%E9%A3%9E%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution强行二合一海星… c的贡献直接曼哈顿距离转切比雪夫距离然后扫描线就好了.1234567ll ans=0;for(int i=1;i&lt;=tot;i++)&#123; int Y=lower_bound(o+1,o+len+1,p[i].y)-o; if(p[i].opt)modify(Y,p[i].opt); else ans+=query(Y)&gt;0;&#125; a,b的贡献考虑显然可以全用对向交换达成目标,那么现在问题转换成了:如何使用最多的擦肩而过满足条件.每次的对向交换在最终的排列p上的作用体现即为交换了某两个元素的位置,所以我们只需要用最小的交换次数将p还原成原排列即可.123456for(int i=1;i&lt;=n;i++)f[i]=i;sort(f+1,f+n+1,cmp);int num=0;for(int i=1;i&lt;=n;i++)g[f[i]]=i;for(int i=1;i&lt;=n;i++) if(f[i]!=i) f[g[i]]=f[i],g[f[i]]=g[i],num++; 代码实现交点不能够乱算…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1000010;const double eps=1e-10;struct point&#123; double x,y; int opt; bool operator&lt;(const point &amp;b)const&#123;return x&lt;b.x;&#125;&#125;p[N];double o[N];int n,a,b,c,x_st,x_ed,Y0[N],Y1[N],tot,len;typedef pair&lt;double,int&gt; pii;#define mp make_pairset&lt;pii&gt;se;int C[N],f[N],g[N];bool cmp(int a,int b)&#123;return Y1[a]&lt;Y1[b];&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void modify(int x,int d)&#123;while(x&lt;=len)C[x]+=d,x+=lowbit(x);&#125;int query(int x)&#123;int ret=0;while(x)ret+=C[x],x-=lowbit(x);return ret;&#125;int main()&#123; freopen("aerobatics.in","r",stdin); freopen("aerobatics.out","w",stdout); n=gi();a=gi();b=gi();c=gi();x_st=gi();x_ed=gi(); for(int i=1;i&lt;=n;i++)Y0[i]=gi(); for(int i=1;i&lt;=n;i++)Y1[i]=gi(); for(int i=n;i;i--) &#123; for(auto j:se) &#123; if(j.first&gt;Y1[i])break;int I=j.second; double k1=(double)((Y0[i]-Y1[i])*1./(x_st-x_ed)),b1=(double)(Y0[i]-k1*1.*x_st),k2=(double)((Y0[I]-Y1[I])*1./(x_st-x_ed)),b2=(double)(Y0[I]-k2*1.*x_st); double x=(double)((b1-b2)*1./(k2-k1)),y=k1*1.*x+b1; p[++tot]=(point)&#123;x+y,x-y,0&#125;;o[++len]=x-y; &#125; se.insert(mp(Y1[i],i)); &#125; int jd=tot; int k=gi(); for(int i=1;i&lt;=k;i++) &#123; int x=gi(),y=gi(),r=gi(); x+=y;y=x-y-y; p[++tot]=(point)&#123;x-r-eps,y-r-eps,1&#125;; p[++tot]=(point)&#123;x-r-eps,y+r+eps,-1&#125;; p[++tot]=(point)&#123;x+r+eps,y-r-eps,-1&#125;; p[++tot]=(point)&#123;x+r+eps,y+r+eps,1&#125;; o[++len]=y-r-eps,o[++len]=y+r+eps; &#125; sort(p+1,p+tot+1);sort(o+1,o+len+1);len=unique(o+1,o+len+1)-o-1; ll ans=0; for(int i=1;i&lt;=tot;i++) &#123; int Y=lower_bound(o+1,o+len+1,p[i].y)-o; if(p[i].opt)modify(Y,p[i].opt); else ans+=query(Y)&gt;0; &#125; ans=1ll*ans*c+1ll*jd*a; for(int i=1;i&lt;=n;i++)f[i]=i; sort(f+1,f+n+1,cmp);int num=0; for(int i=1;i&lt;=n;i++)g[f[i]]=i; for(int i=1;i&lt;=n;i++) if(f[i]!=i) f[g[i]]=f[i],g[f[i]]=g[i],num++; ll ans2=ans+1ll*(jd-num)*(b-a); if(ans&gt;ans2)swap(ans,ans2); printf("%lld %lld\n",ans,ans2); return 0;&#125;#undef mp]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]宝牌一大堆]]></title>
    <url>%2Fgxoi-gzoi2019-%E5%AE%9D%E7%89%8C%E4%B8%80%E5%A4%A7%E5%A0%86%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution考虑如果将杠子看成刻子+1,那么就只有三种和牌的方式: $3*4+2$ 七对子 国士无双 下面用$val$表示对应的收益,$chk$表示更新:12ll val(int x,int y)&#123;return 1ll*c[cnt[x]][y]*(flag[x]?bin[y]:1);&#125;void chk(ll &amp;x,ll y)&#123;x=x&gt;y?x:y;&#125; 七对子我们不妨设$f_{i,j}$表示枚举完了前$i$种牌,选出来了$j$个雀子的最大收益.很容易转移: $f_{i+1,j}=max(f_{i+1,j},f_{i,j}*val)$然后答案就是$f_{34,7}$123456789101112ll solve2()&#123; static ll dp[35][8];memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;34;i++) for(int j=0;j&lt;=7;j++) &#123; chk(dp[i+1][j],dp[i][j]); if(j&lt;7)chk(dp[i+1][j+1],1ll*dp[i][j]*val(i+1,2)); &#125; return dp[34][7]*7ll;&#125; 国士无双发现只有给出的13种牌有用,那么接着$dp$!设$dp_{i,j}$表示前$i$种牌(钦定的13种),现在有$j$张牌.容易转移:$dp_{i+1,j+1}=dp_{i,j}*val$$dp_{i+1,j+2}$1234567891011ll solve3()&#123; static ll dp[14][15];memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;13;i++) for(int j=0;j&lt;14;j++) if(dp[i][j]) for(int k=1;k&lt;=2 &amp;&amp; k&lt;=cnt[scholar[i+1]];k++) chk(dp[i+1][j+k],1ll*dp[i][j]*val(scholar[i+1],k)); return dp[13][14]*13;&#125; 3*4+2如果做过麻将那么你就会做出来这道题!设$f_{i,j,k,a,b}$表示枚举了前$i$种牌,钦定以$i-1$开头的顺子有$j$个,以$i$开头的顺子有$k$个,已经组成了$a$个面子,$b$表示有无雀子.然后一顿乱转移就是了.123456789101112131415161718192021222324ll solve1()&#123; static ll f[35][3][3][5][2];memset(f,0,sizeof(f)); f[0][0][0][0][0]=1; for(int i=0;i&lt;34;i++) for(int j=0;j&lt;3;j++) if(!j || (i&gt;7 &amp;&amp; (i-7)%9!=1 &amp;&amp; (i-7)%9!=0)) for(int k=0;k&lt;3;k++) if(!k || (i&gt;7 &amp;&amp; (i-7)%9!=8 &amp;&amp; (i-7)%9!=0)) if(cnt[i+1]&gt;=j+k) for(int a=j+k;a&lt;=4;a++) for(int b=0;b&lt;2;b++) if(f[i][j][k][a][b]) &#123; for(int c=0;c&lt;=2 &amp;&amp; j+k+c&lt;=cnt[i+1] &amp;&amp; a+c&lt;=4;c++) for(int d=0;j+k+c+d*3&lt;=cnt[i+1] &amp;&amp; a+c+d&lt;=4;d++) &#123; int use=j+k+c+d*3;//d是刻子. chk(f[i+1][k][c][a+c+d][b],1ll*f[i][j][k][a][b]*val(i+1,use)); if(!b &amp;&amp; use+2&lt;=cnt[i+1])chk(f[i+1][k][c][a+c+d][1],1ll*f[i][j][k][a][b]*val(i+1,use+2)); &#125; &#125; return f[34][0][0][4][1];&#125; 为什么没有杠子呢?因为选杠子一定不优啊! 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;int c[10][10],bin[5]=&#123;1,2,4,8,16&#125;;const int N=1010;int cnt[N],flag[N];ll val(int x,int y)&#123;return 1ll*c[cnt[x]][y]*(flag[x]?bin[y]:1);&#125;void chk(ll &amp;x,ll y)&#123;x=x&gt;y?x:y;&#125;ll solve1()&#123; static ll f[35][3][3][5][2];memset(f,0,sizeof(f)); f[0][0][0][0][0]=1; for(int i=0;i&lt;34;i++) for(int j=0;j&lt;3;j++) if(!j || (i&gt;7 &amp;&amp; (i-7)%9!=1 &amp;&amp; (i-7)%9!=0)) for(int k=0;k&lt;3;k++) if(!k || (i&gt;7 &amp;&amp; (i-7)%9!=8 &amp;&amp; (i-7)%9!=0)) if(cnt[i+1]&gt;=j+k) for(int a=j+k;a&lt;=4;a++) for(int b=0;b&lt;2;b++) if(f[i][j][k][a][b]) &#123; for(int c=0;c&lt;=2 &amp;&amp; j+k+c&lt;=cnt[i+1] &amp;&amp; a+c&lt;=4;c++) for(int d=0;j+k+c+d*3&lt;=cnt[i+1] &amp;&amp; a+c+d&lt;=4;d++) &#123; int use=j+k+c+d*3;//d是刻子. chk(f[i+1][k][c][a+c+d][b],1ll*f[i][j][k][a][b]*val(i+1,use)); if(!b &amp;&amp; use+2&lt;=cnt[i+1])chk(f[i+1][k][c][a+c+d][1],1ll*f[i][j][k][a][b]*val(i+1,use+2)); &#125; &#125; return f[34][0][0][4][1];&#125;ll solve2()&#123; static ll dp[35][8];memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;34;i++) for(int j=0;j&lt;=7;j++) &#123; chk(dp[i+1][j],dp[i][j]); if(j&lt;7)chk(dp[i+1][j+1],1ll*dp[i][j]*val(i+1,2)); &#125; return dp[34][7]*7ll;&#125;int scholar[14]=&#123;0,1,2,3,4,5,6,7,8,16,17,25,26,34&#125;;ll solve3()&#123; static ll dp[14][15];memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;13;i++) for(int j=0;j&lt;14;j++) if(dp[i][j]) for(int k=1;k&lt;=2 &amp;&amp; k&lt;=cnt[scholar[i+1]];k++) chk(dp[i+1][j+k],1ll*dp[i][j]*val(scholar[i+1],k)); return dp[13][14]*13;&#125;int read()&#123; char ch=getchar(); while((ch&lt;'0' || ch&gt;'9') &amp;&amp; (ch!='E' &amp;&amp; ch!='S' &amp;&amp; ch!='W' &amp;&amp; ch!='N' &amp;&amp; ch!='Z' &amp;&amp; ch!='F' &amp;&amp; ch!='B'))ch=getchar(); if(ch=='0')return 0; if(ch=='E')return 1; if(ch=='S')return 2; if(ch=='W')return 3; if(ch=='N')return 4; if(ch=='Z')return 5; if(ch=='F')return 6; if(ch=='B')return 7; int num=ch-'0';ch=getchar(); if(ch=='m')num+=25; if(ch=='p')num+=7; if(ch=='s')num+=16; return num;&#125;void init()&#123; c[0][0]=1; for(int i=1;i&lt;=4;i++) &#123; c[i][0]=c[i][i]=1; for(int j=1;j&lt;i;j++) c[i][j]=c[i-1][j]+c[i-1][j-1]; &#125;&#125;int main()&#123; freopen("doraippai.in","r",stdin); freopen("doraippai.out","w",stdout); int T=gi();init(); while(T--) &#123; for(int i=1;i&lt;=34;i++)cnt[i]=4,flag[i]=0;int x; while(1)&#123;x=read();if(!x)break;cnt[x]--;&#125; while(1)&#123;x=read();if(!x)break;flag[x]=1;&#125; printf("%lld\n",max(solve1(),max(solve2(),solve3()))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[GXOI/GZOI2019]与或和]]></title>
    <url>%2Fgxoi-gzoi2019-%E4%B8%8E%E6%88%96%E5%92%8C%2F</url>
    <content type="text"><![CDATA[传送门Loj Solution考虑二进制拆位,那么现在对于每一位矩阵只可能是$0$或$1$,具有贡献的就是$1$. $\&amp;$运算如果要是$1$,只能够全是$1$. $|$运算如果要是有一个$1$,那么就是$1$. 发现这个$|$不好算,那么考虑它的逆命题: 如果全是$0$,那么就是$0$. 发现这是一个相同的过程,接下来就是求全$0/1$的过程了.首先算每一个点能够向上扩展多少,枚举$(i,j)$作为矩形的右下角,对于前面的元素维护一个向上扩展的单调栈,直接算贡献就好了.emm,注意以$(i,j)$为右下角的矩阵个数为$i*j$. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=g/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re registerinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1010,Mod=1e9+7;int n,a[N][N],A[N][N],c[N][N],sta[N],top;int main()&#123; freopen("andorsum.in","r",stdin); freopen("andorsum.out","w",stdout); n=gi(); for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) a[i][j]=gi(); int val=1;ll ans=0; for(re int k=0;k&lt;31;k++,val&lt;&lt;=1) &#123; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) A[i][j]=(a[i][j]&gt;&gt;k)&amp;1; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) if(A[i][j])c[i][j]=c[i-1][j]+1; else c[i][j]=0; for(re int i=1;i&lt;=n;i++) &#123; top=0;ll sum=0; for(re int j=1;j&lt;=n;j++) &#123; sum=(sum+c[i][j])%Mod; while(top &amp;&amp; c[i][sta[top]]&gt;=c[i][j]) &#123; sum=(sum-1ll*(c[i][sta[top]]-c[i][j])*(sta[top]-sta[top-1])+Mod)%Mod; top--; &#125; sta[++top]=j; ans=(ans+1ll*sum*val%Mod)%Mod; &#125; &#125; &#125; printf("%lld ",ans); val=1;ans=0; for(re int k=0;k&lt;31;k++,val&lt;&lt;=1) &#123; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) A[i][j]=((a[i][j]&gt;&gt;k)&amp;1)^1; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) if(A[i][j])c[i][j]=c[i-1][j]+1; else c[i][j]=0; for(re int i=1;i&lt;=n;i++) &#123; top=0;ll sum=0; for(re int j=1;j&lt;=n;j++) &#123; sum=(sum+c[i][j])%Mod; while(top &amp;&amp; c[i][sta[top]]&gt;=c[i][j]) &#123; sum=(sum-1ll*(c[i][sta[top]]-c[i][j])*(sta[top]-sta[top-1])+Mod)%Mod; top--; &#125; sta[++top]=j; ans=(ans+1ll*(i*j-sum)*val%Mod)%Mod; &#125; &#125; &#125; printf("%lld\n",ans); return 0;&#125;etchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1010,Mod=1e9+7;int n,a[N][N],A[N][N],c[N][N],sta[N],top;int main()&#123; file("andorsum"); n=gi(); for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) a[i][j]=gi(); int val=1;ll ans=0; for(re int k=0;k&lt;31;k++,val&lt;&lt;=1) &#123; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) A[i][j]=(a[i][j]&gt;&gt;k)&amp;1; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) if(A[i][j])c[i][j]=c[i-1][j]+1; else c[i][j]=0; for(re int i=1;i&lt;=n;i++) &#123; top=0;ll sum=0; for(re int j=1;j&lt;=n;j++) &#123; sum=(sum+c[i][j])%Mod; while(top &amp;&amp; c[i][sta[top]]&gt;=c[i][j]) &#123; sum=(sum-1ll*(c[i][sta[top]]-c[i][j])*(sta[top]-sta[top-1])+Mod)%Mod; top--; &#125; sta[++top]=j; ans=(ans+1ll*sum*val%Mod)%Mod; &#125; &#125; &#125; printf("%lld ",ans); val=1;ans=0; for(re int k=0;k&lt;31;k++,val&lt;&lt;=1) &#123; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) A[i][j]=((a[i][j]&gt;&gt;k)&amp;1)^1; for(re int i=1;i&lt;=n;i++) for(re int j=1;j&lt;=n;j++) if(A[i][j])c[i][j]=c[i-1][j]+1; else c[i][j]=0; for(re int i=1;i&lt;=n;i++) &#123; top=0;ll sum=0; for(re int j=1;j&lt;=n;j++) &#123; sum=(sum+c[i][j])%Mod; while(top &amp;&amp; c[i][sta[top]]&gt;=c[i][j]) &#123; sum=(sum-1ll*(c[i][sta[top]]-c[i][j])*(sta[top]-sta[top-1])+Mod)%Mod; top--; &#125; sta[++top]=j; ans=(ans+1ll*(i*j-sum)*val%Mod)%Mod; &#125; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1154G Minimum Possible LCM]]></title>
    <url>%2Fcf1154g-minimum-possible-lcm%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译Description给定一个长度为 $n$ 的序列 $a$，找出两个数，最小化他们的最小公倍数 Input第一行是一个整数 $n$下面一行 $n$ 个整数描述这个序列 Output输出一行两个整数代表这两个数在序列中的位置。如果有多解则任意输出一个即可。 Solution神仙题啊! 考虑$lcm$怎么算?$lcm$=$i$*$j$/$gcd$ 发现这个式子里面的$gcd$的范围可以枚举,那么直接枚举$gcd$,拿最小的两个出来算$lcm$就好了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)#define int llinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=1000010,Max=1e7;int vis[Max+10],a[N],n,ans1,ans2;ll ans;signed main()&#123; n=gi();ans=1e18+10; for(re int i=1;i&lt;=n;i++) &#123; a[i]=gi(); if(!vis[a[i]])vis[a[i]]=i; else if(ans&gt;a[i])&#123;ans=a[i];ans1=i;ans2=vis[a[i]];&#125; &#125; for(re int i=1;i&lt;=Max;i++) &#123; re ll find1=0,find2=0,where1,where2; for(re int j=i;j&lt;=Max;j+=i) &#123; if(!vis[j])continue; if(!find1)&#123;find1=j;where1=vis[j];continue;&#125; find2=j;where2=vis[j]; re ll lcm=1ll*find1/i*find2; if(lcm&lt;ans)&#123;ans=lcm;ans1=where1,ans2=where2;&#125; break; &#125; &#125; if(ans1&gt;ans2)swap(ans1,ans2); printf("%lld %lld\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5312 - 冒险]]></title>
    <url>%2Fbzoj5312-%E5%86%92%E9%99%A9%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solutionemmm,现在考虑一下怎么区间或和区间与.考虑如果一段区间的贡献没有什么用,显然不需要搞.考虑如果|的全是贡献的话,那么显然可以直接搞,就相当于是区间加法.如果&amp;的也是全是的,那么显然也可以直接搞,相当于是区间减法.然后就把这道题目转换成了区间+-然后求mx了.嗯嗯嗯嗯嗯,就是线段树板子了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010;struct node&#123; int And,Or,tag,mx;&#125;t[N&lt;&lt;4];int a[N],n,m;void pushup(int);void add(int,int);void pushdown(int);void build(int,int,int);void modify_and(int,int,int,int,int,int);void modify_or(int,int,int,int,int,int);int query(int,int,int,int,int);int main()&#123; n=gi();m=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi(); build(1,1,n); while(m--) &#123; int opt=gi(),l=gi(),r=gi(); if(opt==1) &#123; int x=gi(); modify_and(1,1,n,l,r,x); &#125; if(opt==2) &#123; int x=gi(); modify_or(1,1,n,l,r,x); &#125; if(opt==3) &#123; printf("%d\n",query(1,1,n,l,r)); &#125; &#125; return 0;&#125;void pushup(int o)&#123; t[o].And=t[o&lt;&lt;1].And&amp;t[o&lt;&lt;1|1].And; t[o].Or=t[o&lt;&lt;1].Or|t[o&lt;&lt;1|1].Or; t[o].mx=max(t[o&lt;&lt;1].mx,t[o&lt;&lt;1|1].mx);&#125;void build(int o,int l,int r)&#123; if(l==r)&#123;t[o].mx=t[o].And=t[o].Or=a[l];return;&#125; int mid=(l+r)&gt;&gt;1; build(o&lt;&lt;1,l,mid);build(o&lt;&lt;1|1,mid+1,r); pushup(o);&#125;void add(int o,int v)&#123; t[o].tag+=v;t[o].And+=v;t[o].Or+=v;t[o].mx+=v;&#125;void pushdown(int o)&#123; if(t[o].tag) &#123; add(o&lt;&lt;1,t[o].tag); add(o&lt;&lt;1|1,t[o].tag); t[o].tag=0; &#125;&#125;void modify_and(int o,int l,int r,int posl,int posr,int k)&#123; if(l&lt;r)pushdown(o); if((t[o].Or&amp;k)==t[o].Or)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And&amp;k)-t[o].And==(t[o].Or&amp;k)-t[o].Or)&#123;add(o,(t[o].And&amp;k)-t[o].And);return;&#125; int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_and(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_and(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else &#123; modify_and(o&lt;&lt;1,l,mid,posl,mid,k); modify_and(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); &#125; pushup(o);&#125;void modify_or(int o,int l,int r,int posl,int posr,int k)&#123; if(l&lt;r)pushdown(o); if((t[o].And|k)==t[o].And)return; if((posl&lt;=l &amp;&amp; r&lt;=posr) &amp;&amp; (t[o].And|k)-t[o].And==(t[o].Or|k)-t[o].Or)&#123;add(o,(t[o].Or|k)-t[o].Or);return;&#125; int mid=(l+r)&gt;&gt;1; if(posr&lt;=mid)modify_or(o&lt;&lt;1,l,mid,posl,posr,k); else if(posl&gt;mid)modify_or(o&lt;&lt;1|1,mid+1,r,posl,posr,k); else &#123; modify_or(o&lt;&lt;1,l,mid,posl,mid,k); modify_or(o&lt;&lt;1|1,mid+1,r,mid+1,posr,k); &#125; pushup(o);&#125;int query(int o,int l,int r,int posl,int posr)&#123; if(l!=r)pushdown(o); if(posl&lt;=l &amp;&amp; r&lt;=posr)return t[o].mx; int mid=(l+r)&gt;&gt;1,res=0; if(posl&lt;=mid)res=max(res,query(o&lt;&lt;1,l,mid,posl,posr)); if(posr&gt;mid)res=max(res,query(o&lt;&lt;1|1,mid+1,r,posl,posr)); return res;&#125;/*Kaiser终于成为冒险协会的一员，这次冒险协会派他去冒险，他来到一处古墓，却被大门上的守护神挡住了去路，守护神给出了一个问题，只有答对了问题才能进入，守护神给出了一个自然数序列a,每次有一下三种操作。1，给出l,r,x，将序列l,r之间的所有数都 and x2，给出l,r,x，将序列l,r之间的所有数都 or x3，给出l,r，询问l,r之间的最大值第一行包含两个整数 n,m 接下来一行包含 n 个整数, 表示a序列，接下来 m 行, 每行描述了一个操作.2&lt;=n&lt;=2e5 2&lt;=q&lt;=2e5,0&lt;=ai&lt;=2^20.*/]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces802C Heidi and Library(hard)]]></title>
    <url>%2Fcodeforces802c-heidi-and-library-hard%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译有$n$天和一个容量为$k$的书架,每天需要第$a_i$本书,买$i$这本书的代价是$c_i$,求满足每天条件的最小代价. Solution显然如果第$i$天需要$a_i$,那么$a_i$必须要在书架上面.考虑像餐巾计划一样把每一天拆成2个点,分别表示拥有的和需要的.显然当前这一天一定是连$(i,i+n,1,-Inf)$表示必须选.后面的随便连一下判断需不需要再买书就好了.最后跑k次费用流的费用就是答案.注意要把n*Inf的代价加上. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define re register#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int Inf=1e7;struct node&#123; int to,nxt,flow,cost;&#125;e[100010];int front[5010],n,s,t,cnt=1,dis[5010],vis[5010],fa[5010],from[5010],a[100010],c[100010];void Add(int u,int v,int flow,int cost)&#123; e[++cnt]=(node)&#123;v,front[u],flow,cost&#125;;front[u]=cnt; e[++cnt]=(node)&#123;u,front[v],0,-cost&#125;;front[v]=cnt;&#125;int flow,k,cost;queue&lt;int&gt;Q;bool SPFA()&#123; for(re int i=s;i&lt;=t;i++)dis[i]=Inf; Q.push(s); dis[s]=0;vis[s]=1; while(!Q.empty())&#123; int u=Q.front();Q.pop();vis[u]=0; for(re int i=front[u];i;i=e[i].nxt)&#123; int v=e[i].to; if(e[i].flow &amp;&amp; dis[v]&gt;dis[u]+e[i].cost)&#123; dis[v]=dis[u]+e[i].cost;fa[v]=u; from[v]=i; if(!vis[v])&#123; vis[v]=1;Q.push(v); &#125; &#125; &#125; &#125; if(dis[t]==Inf)return false; flow++;cost=min(cost,cost+dis[t]); for(re int i=t;i!=s;i=fa[i])&#123; e[from[i]].flow--;e[from[i]^1].flow++; &#125; return true;&#125;void McMf()&#123; while(k--)SPFA();&#125;signed main()&#123; n=gi();k=gi(); t=n*2+1; for(int i=1;i&lt;=n;i++)a[i]=gi(); for(int i=1;i&lt;=n;i++)c[i]=gi(); for(int i=1;i&lt;=n;i++)Add(s,i,1,c[a[i]]); for(int i=1;i&lt;=n;i++)Add(i,i+n,1,-Inf); for(int i=1;i&lt;=n;i++)Add(i+n,t,1,0); for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) &#123; Add(i+n,j,1,a[i]==a[j]?0:c[a[j]]); &#125; cost+=1ll*n*Inf;k=min(k,n); McMf(); printf("%d\n",cost); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HAOI2011]防线建设]]></title>
    <url>%2Fhaoi2011-%E9%98%B2%E7%BA%BF%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[$\texttt{stO}​$ $\color{red}h \color{black}{yjhyj​}$ $\texttt{Orz}​$ 传送门BZOJ 然而是权限题 洛谷 Solution不会凸包的出门右转→ 考虑我们不会删点的动态凸包,但是这道题目只有删点,所以删点=加点! 那么怎么动态维护可以加点的凸包呢? 很显然每加入一个然后删除一些没有用的点就可以了. 这个东西平衡树查一下前驱就可以实现. set大法好! 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=200010;struct P&#123; int x,y; bool operator&lt;(const P &amp;b)const &#123; return x&lt;b.x || (x==b.x &amp;&amp; y&lt;b.y); &#125; int operator*(const P &amp;b)const &#123; return x*b.y-y*b.x; &#125; P operator-(const P &amp;b)const &#123; return (P)&#123;x-b.x,y-b.y&#125;; &#125;&#125;city[N];set&lt;P&gt;t;double now,ans[N];int del[N],tot,T,ask[N],n,x,y,mark[N];double dis(P a,P b)&#123; return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;void insert(P &amp;x)&#123; set&lt;P&gt;::iterator r=t.lower_bound(x),l=r,tmp; l--; if((*r-*l)*(x-*l)&lt;0)return; now-=dis(*l,*r); t.insert(x); while(1) &#123; tmp=r;r++; if(r==t.end())break; if((*r-x)*(*tmp-x)&gt;0)break; now-=dis(*tmp,*r); t.erase(tmp); &#125; while(l!=t.begin()) &#123; tmp=l;l--; if((*tmp-x)*(*l-x)&gt;0)break; now-=dis(*tmp,*l); t.erase(tmp); &#125; t.insert(x); l=r=t.find(x); l--;r++; now+=dis(*l,x)+dis(x,*r);&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);#endif n=gi();x=gi(),y=gi(); t.insert((P)&#123;0,0&#125;); t.insert((P)&#123;n,0&#125;); P cap=(P)&#123;x,y&#125;; t.insert(cap); now+=dis((P)&#123;0,0&#125;,cap); now+=dis((P)&#123;n,0&#125;,cap); int m=gi(); for(int i=1;i&lt;=m;i++) &#123; int a=gi(),b=gi(); city[i]=(P)&#123;a,b&#125;; &#125; int q=gi(); for(int i=1;i&lt;=q;i++) &#123; int opt=gi(); if(opt==1)&#123;int x=gi();del[++tot]=x,mark[x]=1;&#125; else ask[++T]=tot; &#125; for(int i=1;i&lt;=m;i++) if(!mark[i])insert(city[i]); for(int i=T;i&gt;=1;i--) &#123; while(tot&gt;ask[i]) &#123; insert(city[del[tot]]); tot--; &#125; ans[i]=now; &#125; for(int i=1;i&lt;=T;i++) printf("%.2lf\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
        <tag>动态凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO5.1] 圈奶牛Fencing the Cows]]></title>
    <url>%2Fusaco5-1-%E5%9C%88%E5%A5%B6%E7%89%9Bfencing-the-cows%2F</url>
    <content type="text"><![CDATA[传送门传送门 Solution这里主要介绍一下怎么写Andrew求凸包. 考虑我们按照 $x,y$ 的顺序排序,发现左下角和右上角的一定在凸包里面. 那么按照一般性的凸包求法然后叉积判一下就好了. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=10010;struct node&#123; double x,y; node operator-(const node&amp;b)const&#123;return (node)&#123;x-b.x,y-b.y&#125;;&#125;&#125;a[N];int n,top,s[N];bool cmp(node a,node b)&#123; return a.x&lt;b.x || (a.x==b.x &amp;&amp; a.y&lt;b.y);&#125;double cross(node a,node b)&#123; return a.x*b.y-a.y*b.x;&#125;double length(node a,node b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++) &#123; scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y); &#125; sort(a+1,a+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; while(top&gt;1 &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; &#125; int tmp=top; for(int i=n-1;i&gt;=1;i--) &#123; while(top&gt;tmp &amp;&amp; cross(a[s[top]]-a[s[top-1]],a[i]-a[s[top-1]])&lt;=0)top--; s[++top]=i; &#125; double Dis=0; for(int i=1;i&lt;top;i++) Dis+=length(a[s[i]],a[s[i+1]]); Dis+=length(a[s[1]],a[s[top]]); printf("%.2lf\n",Dis); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3691 旅行]]></title>
    <url>%2Fbzoj3691-%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[传送门BZOJ 然而是权限题 Solution考虑C是变化的,然后他那个第一个部分的计算和费用流是不是很像? 然后把后面的放在一起算,前面的算一下费用流. 因为最短路是单调的,所以费用流的增广是一个单峰. 然后就可以了,在这个上面二分一下就知道答案了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=510,M=200010,Inf=1e9+10;int n,m,s,t,MaxFlow,MinCost,Q,g[N][N],val[N],tot,sum[N];int front[N],cnt,nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],c[M&lt;&lt;1],dis[N],vis[N],fa[N],from[N];bool SPFA()&#123; queue&lt;int &gt;Q;while(!Q.empty())Q.pop(); Q.push(s);memset(dis,127/2,sizeof(dis));vis[s]=1;dis[s]=0; while(!Q.empty())&#123; int u=Q.front();Q.pop();vis[u]=0; for(int i=front[u];i!=-1;i=nxt[i])&#123; int v=to[i]; if(w[i] &amp;&amp; dis[v]&gt;dis[u]+c[i])&#123; dis[v]=dis[u]+c[i];from[v]=i;fa[v]=u; if(!vis[v])&#123; vis[v]=1;Q.push(v); &#125; &#125; &#125; &#125; return dis[t+1]!=dis[t];&#125;void Add_edge(int u,int v,int val,int f)&#123;to[cnt]=v;nxt[cnt]=front[u];front[u]=cnt;w[cnt]=val;c[cnt]=f;++cnt;&#125;void Add(int u,int v,int val,int f)&#123;Add_edge(u,v,val,f);Add_edge(v,u,0,-f);&#125;void init()&#123;memset(front,-1,sizeof(front));cnt=0;&#125;void Solve()&#123; while(SPFA())&#123; int d=Inf; for(int i=t;i!=s;i=fa[i])d=min(d,w[from[i]]); MaxFlow+=d;MinCost+=d*dis[t]; val[++tot]=d*dis[t];sum[tot]=sum[tot-1]+val[tot]; for(int i=t;i!=s;i=fa[i])&#123;w[from[i]]-=d;w[from[i]^1]+=d;&#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin);// freopen("out.out","w",stdout);#endif init(); n=gi();m=gi();Q=gi();s=0;t=n*2+1; memset(g,127/2,sizeof(g)); for(int i=1;i&lt;=n;i++) g[i][i]=0; for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi(),w=gi(); g[u][v]=min(g[u][v],w); &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) g[i][j]=min(g[i][j],g[i][k]+g[k][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(i^j) Add(i,j+n,1,g[i][j]); for(int i=1;i&lt;=n;i++)Add(s,i,1,0),Add(i+n,t,1,0); Solve(); while(Q--) &#123; int C=gi(),l=1,r=tot,ans=0; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(val[mid]&gt;C)r=mid-1; else&#123;l=mid+1;ans=mid;&#125; &#125; printf("%d\n",sum[ans]+(n-ans)*C); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1149 PIGS]]></title>
    <url>%2Fpoj1149-pigs%2F</url>
    <content type="text"><![CDATA[传送门POJ 题目翻译现在有 $m$ 个猪圈,分别有 $a_i$ 头猪. 有 $n$ 个人要买猪,在 $k$ 个猪圈里面选,最多买 $b$ 头猪. 问最多买多少头猪. Solution发现这个数据范围很像网络流啊. 我们新建一个 $s$ , $t$ 节点. 把每一个人向 $t$ 节点连一个需求量,考虑每一个猪圈怎么解决: 我们想一下怎么转换模型,如果可以调换的话,相当于就是这些猪是一个整体对吧. 所以我们可以考虑把 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* mail: mleautomaton@foxmail.com author: MLEAutoMaton This Code is made by MLEAutoMaton*/#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=10010,M=200010,Inf=1e9+10;int front[N],nxt[M&lt;&lt;1],to[M&lt;&lt;1],w[M&lt;&lt;1],cnt=1,s,t,dep[N],m,n,pig[N],bl[N],cur[N];vector&lt;int&gt;g[N];queue&lt;int&gt;Q;void Add_edge(int u,int v,int val)&#123; to[++cnt]=v;nxt[cnt]=front[u];w[cnt]=val;front[u]=cnt;&#125;void Add(int u,int v,int val)&#123; Add_edge(u,v,val); Add_edge(v,u,0);&#125;bool bfs()&#123; memset(dep,0,sizeof(dep)); dep[s]=1;Q.push(s); while(!Q.empty()) &#123; int u=Q.front();Q.pop(); for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(w[i] &amp;&amp; !dep[v]) &#123; dep[v]=dep[u]+1;Q.push(v); &#125; &#125; &#125; return dep[t];&#125;int dfs(int u,int flow)&#123; if(u==t || !flow)return flow; for(int &amp;i=cur[u];i;i=nxt[i]) &#123; int v=to[i]; if(dep[v]==dep[u]+1 &amp;&amp; w[i]) &#123; int di=dfs(v,min(flow,w[i])); if(di) &#123; w[i]-=di;w[i^1]+=di; return di; &#125; &#125; &#125; return 0;&#125;int Dinic()&#123; int flow=0; while(bfs()) &#123; for(int i=s;i&lt;=t;i++)cur[i]=front[i]; while(int d=dfs(s,Inf))flow+=d; &#125; return flow;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif memset(front,-1,sizeof(front)); m=gi();n=gi();t=n+1; for(int i=1;i&lt;=m;i++)pig[i]=gi(); for(int i=1;i&lt;=n;i++) &#123; int k=gi(); for(int j=1;j&lt;=k;j++) g[i].push_back(gi()); Add(i,t,gi()); &#125; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;g[i].size();j++) &#123; int v=g[i][j]; if(!bl[v]) &#123; bl[v]=i; Add(s,i,pig[v]); &#125; else &#123; Add(bl[v],i,Inf); bl[v]=i; &#125; &#125; &#125; printf("%d\n",Dinic()); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeChef Querying on a Grid]]></title>
    <url>%2Fcodechef-querying-on-a-grid%2F</url>
    <content type="text"><![CDATA[传送门CodeChef 题目翻译给你一个m*n的网格图(m&lt;=3),有Q个询问:opt=1,将(x1,y1)-&gt;(x2,y2)的最短路上的点权+c.opt=2,求点(x,y)的点权. Solution 网格图的一个基本套路就是分治(蒯的). 那么我们考虑分治,对于mid上面的3个点求一个最短路径树,那么现在最短路的长度就已知了. 然后再分治找路径就知道是路径了. 接着考虑修改,直接把这个修改改成子树修改就好了. 具体实现参考代码. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long longinline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;inline ll gl()&#123; ll f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=300010,M=4;typedef pair&lt;ll,int&gt; pii;#define mp make_pairvector&lt;pii&gt;g[N];int m,n,Q,tot,id[N][M];ll Max;struct node&#123; ll dis[N],c[N]; int fa[N],dfn[N],low[N],Time; vector&lt;int&gt;son[N]; bool vis[N]; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; void dfs(int u) &#123; dfn[u]=++Time; for(int v:son[u])dfs(v); low[u]=Time; &#125; int lowbit(int x) &#123; return x&amp;(-x); &#125; void Add(int x,ll d) &#123; x=dfn[x]; while(x&lt;=Time) &#123; c[x]+=d; x+=lowbit(x); &#125; &#125; ll query(int x) &#123; ll ret=0;int tmp=x; tmp=low[x];while(tmp)&#123;ret+=c[tmp];tmp-=lowbit(tmp);&#125; tmp=dfn[x]-1;while(tmp)&#123;ret-=c[tmp];tmp-=lowbit(tmp);&#125; return ret; &#125; void dijkstra(int l,int r,int s) &#123; for(int i=l;i&lt;=r;i++) dis[i]=1e18,vis[i]=false; dis[s]=0; q.push(mp(0,s)); while(!q.empty()) &#123; pii now=q.top();q.pop(); int u=now.second; if(vis[u])continue; vis[u]=1; for(pii i:g[u]) &#123; int v=i.second;ll w=i.first; if(v&lt;l || v&gt;r || dis[v]&lt;=dis[u]+w)continue; dis[v]=dis[u]+w; fa[v]=u; q.push(mp(dis[v],v)); &#125; &#125; for(int i=l;i&lt;=r;i++) if(i!=s)son[fa[i]].push_back(i); dfs(s); &#125;&#125;t[20][M];void build(int l,int r,int dep)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) t[dep][i].dijkstra(id[l][0],id[r][m-1],id[mid][i]); if(l&lt;mid)build(l,mid-1,dep+1); if(r&gt;mid)build(mid+1,r,dep+1);&#125;void calc(int l,int r,int dep,int u,int v)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) Max=min(Max,t[dep][i].dis[u]+t[dep][i].dis[v]); if(u&lt;=id[mid][m-1] &amp;&amp; v&gt;=id[mid][0])return; if(v&lt;id[mid][0])calc(l,mid-1,dep+1,u,v); else calc(mid+1,r,dep+1,u,v);&#125;void modify(int l,int r,int dep,int x,int y,ll w)&#123; int mid=(l+r)&gt;&gt;1; for(int i=0;i&lt;m;i++) if(t[dep][i].dis[x]+t[dep][i].dis[y]==Max) &#123; t[dep][i].Add(x,w); t[dep][i].Add(y,w); return; &#125; if(y&lt;id[mid][0])modify(l,mid-1,dep+1,x,y,w); else modify(mid+1,r,dep+1,x,y,w);&#125;ll query(int l,int r,int dep,int u)&#123; int mid=(l+r)&gt;&gt;1;ll ret=0; for(int i=0;i&lt;m;i++) &#123; ll s=t[dep][i].query(u); if(id[mid][i]==u)s&gt;&gt;=1; ret+=s; &#125; if(u&lt;id[mid][0])ret+=query(l,mid-1,dep+1,u); if(u&gt;id[mid][m-1])ret+=query(mid+1,r,dep+1,u); return ret;&#125;int main()&#123; m=gi();n=gi();Q=gi(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) id[i][j]=++tot; for(int i=0;i&lt;m-1;i++) for(int j=0;j&lt;n;j++) &#123; int u=id[j][i],v=id[j][i+1];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n-1;j++) &#123; int u=id[j][i],v=id[j+1][i];ll w=gl(); g[u].push_back(mp(w,v)); g[v].push_back(mp(w,u)); &#125; build(0,n-1,0); while(Q--) &#123; int opt=gi(); if(opt==1) &#123; int x=gi()-1,y=gi()-1,xx=gi()-1,yy=gi()-1;ll c=gl(); int u=id[y][x],v=id[yy][xx]; if(u&gt;v)swap(u,v); Max=1e18;calc(0,n-1,0,u,v); modify(0,n-1,0,u,v,c); &#125; else &#123; int x=gi()-1,y=gi()-1; int u=id[y][x]; printf("%lld\n",query(0,n-1,0,u)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>分治</tag>
        <tag>最短路径树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder3611 Tree MST]]></title>
    <url>%2Fatcoder3611-tree-mst%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给你$n$个点的树,每条边有边权,每一个点有点权. 他们两两之间可以构成一个完全图,边$(u,v)$的代价是$w_u+w_v+dis(u,v)$. 求它的最小生成树. Solution考虑这个式子的形成: $w_u+w_v+dis(u,v)$ emmm,发现有个dis,考虑一下点分治! 对于每一个重心的子树,找一个$dis(u,root)+w[u]$的最小的点. 那么其他的点一定在这个子树里面到他最优. 然后直接连边然后跑最小生成树就好了. 复杂度的证明的话,就是: 点分的复杂度是$O(nlog(n))$的. 加入的边的级别是$O(nlog(n))$的. 总复杂度就是$O(nlog(n)^2)$的. 那么就可以放心的写了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;#define ll long long#define re registerusing namespace std;inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&lt;='9' &amp;&amp; ch&gt;='0')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=233333;int front[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],w[N&lt;&lt;1],W[N],n,m,cnt;int siz[N],g[N],root,sum,vis[N];struct node&#123; int u,v;ll w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N*50];ll Min;int p;void Add(int u,int v,int val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;void getroot(int u,int fa)&#123; siz[u]=1;g[u]=0; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; getroot(v,u); siz[u]+=siz[v]; g[u]=max(g[u],siz[v]); &#125; g[u]=max(g[u],sum-siz[u]); if(g[u]&lt;g[root])root=u;&#125;void dfs(int u,int fa,ll dep)&#123; if(Min&gt;W[u]+dep)&#123;Min=W[u]+dep;p=u;&#125; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; dfs(v,u,dep+w[i]); &#125;&#125;void Link(int u,int fa,ll dep)&#123; e[++m]=(node)&#123;u,p,dep+Min+W[u]&#125;; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(v==fa || vis[v])continue; Link(v,u,dep+w[i]); &#125;&#125;void solve(int u)&#123; vis[u]=1; Min=1e18+10;p=0; dfs(u,0,0);Link(u,0,0); for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(vis[v])continue; sum=siz[v];root=0; getroot(v,u); solve(root); &#125;&#125;int f[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)W[i]=gi(); for(int i=1;i&lt;n;i++) &#123; int u=gi(),v=gi(),val=gi(); Add(u,v,val);Add(v,u,val); &#125; g[0]=n+1;sum=n; getroot(1,0); solve(root); sort(e+1,e+m+1); for(int i=1;i&lt;=n;i++)f[i]=i; ll ans=0;int k=0; for(int i=1;i&lt;=m;i++) &#123; int u=find(e[i].u),v=find(e[i].v); if(u!=v) &#123; ans+=e[i].w; k++;f[v]=u; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>Kruscal</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JSOI2010]满汉全席]]></title>
    <url>%2Fjsoi2010-%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD%2F</url>
    <content type="text"><![CDATA[传送门BZOJ Solution这不就是2-SAT的模板题?不会2-SAT模板?那你也是很菜了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=210,M=1010;int front[N],to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,dfn[N],Time,low[N],s[N],vis[N],sta,n,m,scc,bl[N];inline void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++Time;s[sta++]=u;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(!dfn[v]) &#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(vis[v])low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u]) &#123; scc++; int x; do &#123; x=s[--sta]; bl[x]=scc; vis[x]=0; &#125;while(x!=u); &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; n=gi();m=gi(); for(re int i=1;i&lt;=n*2;i++)front[i]=0;cnt=0;Time=0;scc=0; for(re int i=1;i&lt;=n*2;i++)dfn[i]=low[i]=0; for(re int i=1;i&lt;=m;i++) &#123; char ch=getchar();int a,b,x,y; while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); a=ch=='h'; x=gi(); ch=getchar(); while(ch!='m' &amp;&amp; ch!='h')ch=getchar(); b=ch=='h'; y=gi(); Add(x+a*n,y+(b^1)*n); Add(y+b*n,x+(a^1)*n); &#125; for(re int i=1;i&lt;=2*n;i++)if(!dfn[i])tarjan(i); int flag=0; for(re int i=1;i&lt;=n;i++) if(bl[i]==bl[i+n]) &#123; puts("BAD");flag=1;break; &#125; if(!flag)puts("GOOD"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cerc2012 Farm and factory]]></title>
    <url>%2Fcerc2012-farm-and-factory%2F</url>
    <content type="text"><![CDATA[传送门BZOJ很可惜这是一道权限题. Solution先设: $f_i$表示$1~i$的最短路. $g_i$表示$2~i$的最短路 $s_i$表示$new~i$的最短路 这个东西随便化简一下就是一个切比雪夫距离.发现这是一个正方形,旋转45°就是曼哈顿距离.然后中位数随便搞一下就好了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=100010,M=300010;const double Inf=1e18+10;int to[M&lt;&lt;1],nxt[M&lt;&lt;1],cnt,front[N];typedef pair&lt;double,int&gt; pii;#define mp make_pairpriority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;double f[N],g[N],a[N],b[N],w[M&lt;&lt;1];int vis[N],n,m;void Add(int u,int v,double val)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt; w[cnt]=val;&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif int T=gi(); while(T--) &#123; memset(front,0,sizeof(front));cnt=0; n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; int u=gi(),v=gi();double val;scanf("%lf",&amp;val); Add(u,v,val);Add(v,u,val); &#125; for(int i=1;i&lt;=n;i++)f[i]=Inf,vis[i]=0; f[1]=0.0;q.push(mp(0.0,1)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(f[v]&gt;f[u]+w[i]) &#123; f[v]=f[u]+w[i]; q.push(mp(f[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)g[i]=Inf,vis[i]=0; g[2]=0.0;q.push(mp(0.0,2)); while(!q.empty()) &#123; pii now=q.top();q.pop();int u=now.second; if(vis[u])continue;vis[u]=1; for(int i=front[u];i;i=nxt[i]) &#123; int v=to[i]; if(g[v]&gt;g[u]+w[i]) &#123; g[v]=g[u]+w[i]; q.push(mp(g[v],v)); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) a[i]=f[i]+g[i]; for(int i=1;i&lt;=n;i++) b[i]=f[i]-g[i]; sort(a+1,a+n+1);sort(b+1,b+n+1); double ans=0; for(int i=1;i&lt;=n;i++)ans+=fabs(a[i]-a[(n+1)/2]); for(int i=1;i&lt;=n;i++)ans+=fabs(b[i]-b[(n+1)/2]); ans/=2*n;printf("%.10lf\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atcoder2134 Zigzag MST]]></title>
    <url>%2Fatcoder2134-zigzag-mst%2F</url>
    <content type="text"><![CDATA[传送门Atcoder 题目翻译给出n个点,编号为0~n-1. 现在给出Q个加边操作,每一次的系数为$a,b,c$. 每一次可以插入无限条边,插入规则大致是:$(Ai,Bi,Ci)(Bi,Ai+1,Ci+1),(Ai+1,Bi+1,Ci+2)$等等,求给定图的最小生成树. Solution引入(假)在写题目之前先插播一条广告:有么有人资磁yyb小姐姐和zsy小哥哥在一起啊萝卜你应该要给我广告费 引入(真)如果现在有这样两条边摆在你面前:$(a,b,x)和(b,c,y)$我们知道$x&lt;y$,那么$(b,c,y)$就可以转换为$(a,c,y)$画一个图来深刻理解一下:其实这两个是等价的! 关于本题我们发现它的连边真心鬼畜,按照上面的那个什么替换一下?$(a,b,c)与(b,a+1,c+1)$emmm,这不就是$(a,b,c)与(a,a+1,c+1)$那么我们每一条限制就变成了一堆相邻的边的权值了.当然,注意$(a,b,c)$并没有消失!!!现在问题转换成如何快速求出每一条边的最小权值!注意到$a-&gt;a+1$和$b-&gt;b+1$一定是最小的两条边权,那么后面的一定会用它们更新!于是我们先把$a,b$的权值给赋上,然后按照顺序扫一遍就可以了.最后一个容易咕的地方就是:每次的贡献应当是$+2$而不是$+1$,因为它是两边同时进行. 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=400010;int val[N],n,q,cnt,f[N];ll ans;struct node&#123; int u,v,w; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N&lt;&lt;1];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123; n=gi();q=gi(); memset(val,127,sizeof(val)); for(int i=1;i&lt;=q;i++) &#123; int a=gi(),b=gi(),c=gi(); e[++cnt]=(node)&#123;a,b,c&#125;; val[a]=min(val[a],c+1); val[b]=min(val[b],c+2); &#125; int pos=0; for(int i=1;i&lt;n;i++)if(val[pos]&gt;val[i])pos=i; for(int i=(pos+1)%n,j=pos;i!=pos;j=i,i=(i+1)%n) val[i]=min(val[i],val[j]+2); for(int i=0;i&lt;n-1;i++) e[++cnt]=(node)&#123;i,i+1,val[i]&#125;; e[++cnt]=(node)&#123;n-1,0,val[n-1]&#125;; sort(e+1,e+cnt+1); for(int i=0;i&lt;n;i++)f[i]=i; int k=0; for(int i=1;i&lt;=cnt;i++) &#123; int u=e[i].u,v=e[i].v; if(find(u)!=find(v)) &#123; ans+=e[i].w,f[find(u)]=find(v); k++; if(k==n-1)break; &#125; &#125; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces891C Envy]]></title>
    <url>%2Fcodeforces891c-envy%2F</url>
    <content type="text"><![CDATA[传送门CodeForces 题目翻译给你n个节点,m条边以及q条询问.每一次询问有k条边,询问这k条边能否都在MST上.可以就输出”YES”,否则输出”NO”. Solution这是一个翻遍全网都无法找到的新型题解!(至少在2019.3月份之前找不到)我们考虑最小生成树的一个性质: 加入完相同的边权后连通性是一样的. 证明: 考虑按照各种顺序排序,如果某一条边不会与其他的一同加入而产生环,那么显然他是一定会被加入的 如果有冲突,那么这些边的加入顺序就不重要了,因为他们一定会构成一个环少一条边. 那么利用这个性质,我们很容易做出来这道题目. 对于每一条边,假设它是一个三元组(u,v,w). 维护一个(uu,vv)表示加入完所有的$w’$&lt;$w$的边后的$u$所在的联通块和$v$所在的联通块. 我们考虑不能够插入的情况: 1find(uu)==find(vv) 那么只需要扫一遍所有的边,然后如果有不行的就直接输出”NO”,最后输出”YES”就好了. 当然跑的时候是需要维护连通性的(就是还是要加边!). 还原并查集数组的话可以把(uu,vv)当成是关键点,所以只需要改变这一些点的fa就可以了. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=500010;struct node&#123; int u,v,w,uu,vv,id; bool operator&lt;(const node&amp;b)const &#123; return w&lt;b.w; &#125;&#125;e[N],a[N];int f[N],n,m,q,c[N],id[N];int find(int x)&#123; if(f[x]!=x)f[x]=find(f[x]); return f[x];&#125;int main()&#123;#ifndef ONLINE_JUDGE freopen("in.in","r",stdin); freopen("out.out","w",stdout);#endif n=gi();m=gi(); for(int i=1;i&lt;=m;i++) &#123; e[i].u=gi(),e[i].v=gi(),e[i].w=gi(); e[i].id=i; &#125; sort(e+1,e+m+1); for(int i=1;i&lt;=m;i++) id[e[i].id]=i; for(int i=1;i&lt;=n;i++)f[i]=i; int last=1; for(int i=1;i&lt;=m;i++) &#123; if(e[i].w!=e[i-1].w) &#123; for(int j=last;j&lt;i;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125; last=i; &#125; e[i].uu=find(e[i].u); e[i].vv=find(e[i].v); &#125; for(int j=last;j&lt;=m;j++) &#123; int u=find(e[j].u),v=find(e[j].v); if(u!=v)f[v]=u; &#125;// for(int i=1;i&lt;=m;i++)// printf("%d %d %d %d %d\n",e[i].u,e[i].v,e[i].w,e[i].uu,e[i].vv); q=gi(); while(q--) &#123; int k=gi(),sta=0; for(int i=1;i&lt;=k;i++) c[i]=gi(); for(int i=1;i&lt;=k;i++) &#123; a[++sta]=e[id[c[i]]]; f[a[sta].uu]=a[sta].uu; f[a[sta].vv]=a[sta].vv; &#125; sort(a+1,a+sta+1);int flag=0; for(int i=1;i&lt;=sta;i++) &#123; int u=a[i].uu,v=a[i].vv; if(find(u)==find(v)) &#123; flag=1;break; &#125;// if(!q)printf("%d %d %d %d\n",u,v,find(u),find(v)); f[find(u)]=find(v); &#125; if(flag)puts("NO"); else puts("YES"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>Kruscal</tag>
        <tag>Trick</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2007 覆盖问题]]></title>
    <url>%2Fhaoi2007-%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言小清新思维题. 最近肯定需要一些思维题挽救我这种碰到题目只会模板的菜鸡. 这题腾空出世? Solution考虑一下我们二分答案怎么做? 首先转换一下,将这些点用一个尽可能小的矩形全部覆盖. 那么我们求的三个正方形一定会与这一些边有交. 然后前两个正方形直接看是和哪一个角相交.最后一个因为只剩下一个正方形,判断可行性即可. 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int inf=1e9;struct data&#123;int x[20010],y[20010],top;&#125;;int mid;void cut(data &amp;a,int x1,int y1,int x2,int y2)&#123; int tot=0; for(int i=1;i&lt;=a.top;i++) if(a.x[i]&lt;x1||a.x[i]&gt;x2||a.y[i]&lt;y1||a.y[i]&gt;y2) &#123; tot++; a.x[tot]=a.x[i]; a.y[tot]=a.y[i]; &#125; a.top=tot;&#125; void solve(data &amp;a,int fc)&#123; int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=a.top;i++) &#123; x1=min(a.x[i],x1),x2=max(a.x[i],x2); y1=min(a.y[i],y1),y2=max(a.y[i],y2); &#125; if(fc==1) cut(a,x1,y1,x1+mid,y1+mid); if(fc==2) cut(a,x2-mid,y1,x2,y1+mid); if(fc==3) cut(a,x1,y2-mid,x1+mid,y2); if(fc==4) cut(a,x2-mid,y2-mid,x2,y2);&#125;data a;bool jud()&#123; data b; for(int x=1;x&lt;=4;x++) for(int y=1;y&lt;=4;y++) &#123; b.top=a.top; for(int i=1;i&lt;=b.top;i++) b.x[i]=a.x[i],b.y[i]=a.y[i]; solve(b,x);solve(b,y); int x1=inf,y1=inf,x2=-inf,y2=-inf; for(int i=1;i&lt;=b.top;i++) &#123; x1=min(b.x[i],x1),x2=max(b.x[i],x2); y1=min(b.y[i],y1),y2=max(b.y[i],y2); &#125; if(x2-x1&lt;=mid&amp;&amp;y2-y1&lt;=mid)return 1; &#125; return 0;&#125;int main()&#123; int n=gi(); for(int i=1;i&lt;=n;i++)a.x[i]=gi(),a.y[i]=gi(); a.top=n; int l=1,r=inf,ans=0; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(jud())&#123;r=mid-1;ans=mid;&#125; else l=mid+1; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HAOI2006 数字序列]]></title>
    <url>%2Fhaoi2006-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[dp好题? 第一问第一问我会做!令$b_i=a_i-i$,求一个最长不下降子序列. $n-ans$就是最终的答案. 第二问好难啊.不会.挖坑待补. 考虑一下对于一个i~j的可能符合情况,定然存在一个$k$在i~k之中为$a_i$,k~j之中为$a_j$. 然后就可以dp了. 这个转移比较玄学.如果不随机就GG了. 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;#define ll long long#define re register#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)inline int gi()&#123; int f=1,sum=0;char ch=getchar(); while(ch&gt;'9' || ch&lt;'0')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123;sum=(sum&lt;&lt;3)+(sum&lt;&lt;1)+ch-'0';ch=getchar();&#125; return f*sum;&#125;const int N=50010;int a[N],n,L,cnt,mn[N],f[N],front[N],to[N&lt;&lt;2],nxt[N&lt;&lt;2];ll g[N],s1[N],s2[N];int find(int x)&#123; int l=1,r=L,t=0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(mn[mid]&lt;=x)t=mid,l=mid+1; else r=mid-1; &#125; return t;&#125;void dp()&#123; memset(mn,127,sizeof(mn)); mn[0]=-(1&lt;&lt;30); for(int i=1;i&lt;=n;i++)&#123; int q=find(a[i]); f[i]=q+1; L=max(L,f[i]); mn[q+1]=min(mn[q+1],a[i]); &#125;&#125;void Add(int u,int v)&#123; to[++cnt]=v;nxt[cnt]=front[u];front[u]=cnt;&#125;void solve()&#123; for(int i=n;~i;i--)&#123; Add(f[i],i); g[i]=1ll&lt;&lt;60; &#125; g[0]=0;a[0]=-(1&lt;&lt;30); for(int u=1;u&lt;=n;u++) for(int i=front[f[u]-1];i;i=nxt[i])&#123; int v=to[i]; if(v&gt;u)break; if(a[v]&gt;a[u])continue; for(int j=v;j&lt;=u;j++)s1[j]=abs(a[v]-a[j]),s2[j]=abs(a[u]-a[j]); for(int j=v+1;j&lt;=u;j++) s1[j]+=s1[j-1],s2[j]+=s2[j-1]; for(int j=v;j&lt;u;j++) g[u]=min(g[u],g[v]+s1[j]-s1[v]+s2[u]-s2[j]); &#125;&#125;int main()&#123; n=gi(); for(int i=1;i&lt;=n;i++)a[i]=gi()-i; a[++n]=1&lt;&lt;30; dp();solve(); printf("%d\n%lld\n",n-f[n],g[n]); return 0;&#125;]]></content>
      <categories>
        <category>Solution</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎来到我的博客]]></title>
    <url>%2F%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[欢迎来到我的hexo博客! emmm,我也不知道自己有多少博客,但是这一次一定是最后一个了. 希望能够开的很久吧.]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
